
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>vetbot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drerr0r/vetbot/cmd/vetbot/main.go (0.0%)</option>
				
				<option value="file1">github.com/drerr0r/vetbot/internal/database/database.go (3.9%)</option>
				
				<option value="file2">github.com/drerr0r/vetbot/internal/database/database_testutils.go (21.4%)</option>
				
				<option value="file3">github.com/drerr0r/vetbot/internal/handlers/adapters.go (0.0%)</option>
				
				<option value="file4">github.com/drerr0r/vetbot/internal/handlers/admin_handlers.go (0.1%)</option>
				
				<option value="file5">github.com/drerr0r/vetbot/internal/handlers/bot_handlers.go (12.5%)</option>
				
				<option value="file6">github.com/drerr0r/vetbot/internal/handlers/main_handler.go (18.8%)</option>
				
				<option value="file7">github.com/drerr0r/vetbot/internal/handlers/test_utils.go (60.9%)</option>
				
				<option value="file8">github.com/drerr0r/vetbot/internal/handlers/vet_handlers.go (72.8%)</option>
				
				<option value="file9">github.com/drerr0r/vetbot/pkg/utils/config.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"
        "os/signal"
        "strings"
        "syscall"

        "github.com/drerr0r/vetbot/internal/database"
        "github.com/drerr0r/vetbot/internal/handlers"
        "github.com/drerr0r/vetbot/pkg/utils"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func main() <span class="cov0" title="0">{
        // Загружаем конфигурацию
        config, err := utils.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading config: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Telegram token loaded: %s...", maskToken(config.TelegramToken))
        log.Printf("Database URL loaded: %s", maskDBPassword(config.DatabaseURL))
        log.Printf("Debug mode: %t", config.Debug)
        log.Printf("Admin IDs: %v", config.AdminIDs)

        // Инициализируем бота Telegram
        bot, err := tgbotapi.NewBotAPI(config.TelegramToken)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating bot: %v", err)
        }</span>

        <span class="cov0" title="0">bot.Debug = config.Debug
        log.Printf("Authorized on account %s", bot.Self.UserName)

        // Инициализируем базу данных
        db, err := database.New(config.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error connecting to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // ДОБАВЛЕНО: Добавляем отсутствующие колонки в базу данных
        log.Println("Checking and adding missing database columns...")
        err = db.AddMissingColumns()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: could not add missing columns: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Database columns check completed successfully")
        }</span>

        // Создаем адаптер для бота
        <span class="cov0" title="0">botAdapter := handlers.NewTelegramBotAdapter(bot)

        // Создаем основной обработчик
        mainHandler := handlers.NewMainHandler(botAdapter, db, config)

        // Настраиваем long polling
        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        updates := bot.GetUpdatesChan(u)

        // Обрабатываем сигналы для graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        log.Println("Bot started. Press Ctrl+C to stop.")

        // Основной цикл обработки сообщений
        for </span><span class="cov0" title="0">{
                select </span>{
                case update := &lt;-updates:<span class="cov0" title="0">
                        // Обрабатываем обновление в той же горутине для сохранения порядка сообщений
                        mainHandler.HandleUpdate(update)</span>
                case &lt;-sigChan:<span class="cov0" title="0">
                        log.Println("Shutting down bot gracefully...")
                        return</span>
                }
        }
}

// maskToken маскирует токен для безопасного логирования
func maskToken(token string) string <span class="cov0" title="0">{
        if len(token) &lt;= 10 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov0" title="0">return token[:10] + "..."</span>
}

// maskDBPassword маскирует пароль в URL базы данных для логирования
func maskDBPassword(dbURL string) string <span class="cov0" title="0">{
        parts := strings.Split(dbURL, "@")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return dbURL
        }</span>

        <span class="cov0" title="0">authPart := parts[0]
        if strings.Contains(authPart, ":") </span><span class="cov0" title="0">{
                authParts := strings.Split(authPart, ":")
                if len(authParts) &gt;= 3 </span><span class="cov0" title="0">{ // postgres://user:password@
                        // Находим позицию пароля
                        userPass := strings.Split(authParts[2], "@")
                        if len(userPass) &gt;= 2 </span><span class="cov0" title="0">{
                                // Маскируем пароль
                                return authParts[0] + "://" + authParts[1] + ":***@" + parts[1]
                        }</span>
                } else<span class="cov0" title="0"> if len(authParts) == 2 &amp;&amp; strings.Contains(authParts[0], "//") </span><span class="cov0" title="0">{
                        // Формат user:password@host
                        protocolParts := strings.Split(authParts[0], "//")
                        if len(protocolParts) == 2 </span><span class="cov0" title="0">{
                                return protocolParts[0] + "//" + protocolParts[1] + ":***@" + parts[1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return dbURL</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        "github.com/drerr0r/vetbot/internal/models"
        _ "github.com/lib/pq"
)

// Database представляет обертку для работы с базой данных
type Database struct {
        db *sql.DB
}

// New создает новое подключение к базе данных
func New(dataSourceName string) (*Database, error) <span class="cov8" title="1">{
        db, err := sql.Open("postgres", dataSourceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to database")
        return &amp;Database{db: db}, nil</span>
}

// Close закрывает подключение к базе данных
func (d *Database) Close() error <span class="cov8" title="1">{
        if d == nil || d.db == nil </span><span class="cov8" title="1">{
                return nil // Безопасно возвращаем nil для nil объекта
        }</span>
        <span class="cov0" title="0">return d.db.Close()</span>
}

// GetDB возвращает объект базы данных
func (d *Database) GetDB() *sql.DB <span class="cov0" title="0">{
        return d.db
}</span>

// CreateUser создает нового пользователя
func (d *Database) CreateUser(user *models.User) error <span class="cov0" title="0">{
        query := `INSERT INTO users (telegram_id, username, first_name, last_name, phone) 
                  VALUES ($1, $2, $3, $4, $5) 
                  ON CONFLICT (telegram_id) DO UPDATE SET 
                  username = EXCLUDED.username, 
                  first_name = EXCLUDED.first_name, 
                  last_name = EXCLUDED.last_name, 
                  phone = EXCLUDED.phone
                  RETURNING id, created_at`

        err := d.db.QueryRow(query, user.TelegramID, user.Username, user.FirstName, user.LastName, user.Phone).
                Scan(&amp;user.ID, &amp;user.CreatedAt)
        return err
}</span>

// GetAllSpecializations возвращает все специализации
func (d *Database) GetAllSpecializations() ([]*models.Specialization, error) <span class="cov0" title="0">{
        rows, err := d.db.Query("SELECT id, name, description, created_at FROM specializations ORDER BY name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var specializations []*models.Specialization
        for rows.Next() </span><span class="cov0" title="0">{
                var spec models.Specialization
                err := rows.Scan(&amp;spec.ID, &amp;spec.Name, &amp;spec.Description, &amp;spec.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">specializations = append(specializations, &amp;spec)</span>
        }

        <span class="cov0" title="0">return specializations, nil</span>
}

// GetSpecializationByID возвращает специализацию по ID
func (d *Database) GetSpecializationByID(id int) (*models.Specialization, error) <span class="cov0" title="0">{
        var spec models.Specialization
        err := d.db.QueryRow("SELECT id, name, description, created_at FROM specializations WHERE id = $1", id).
                Scan(&amp;spec.ID, &amp;spec.Name, &amp;spec.Description, &amp;spec.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;spec, nil</span>
}

// SpecializationExists проверяет существование специализации
func (d *Database) SpecializationExists(id int) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := d.db.QueryRow("SELECT EXISTS(SELECT 1 FROM specializations WHERE id = $1)", id).Scan(&amp;exists)
        return exists, err
}</span>

// GetVeterinariansBySpecialization возвращает врачей по специализации
func (d *Database) GetVeterinariansBySpecialization(specializationID int) ([]*models.Veterinarian, error) <span class="cov0" title="0">{
        query := `
                SELECT DISTINCT v.id, v.first_name, v.last_name, v.phone, v.email, 
                       v.description, v.experience_years, v.is_active, v.created_at
                FROM veterinarians v
                INNER JOIN vet_specializations vs ON v.id = vs.vet_id
                WHERE vs.specialization_id = $1 AND v.is_active = true
                ORDER BY v.first_name, v.last_name`

        rows, err := d.db.Query(query, specializationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var veterinarians []*models.Veterinarian
        for rows.Next() </span><span class="cov0" title="0">{
                var vet models.Veterinarian
                err := rows.Scan(&amp;vet.ID, &amp;vet.FirstName, &amp;vet.LastName, &amp;vet.Phone, &amp;vet.Email,
                        &amp;vet.Description, &amp;vet.ExperienceYears, &amp;vet.IsActive, &amp;vet.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Загружаем специализации для каждого врача
                <span class="cov0" title="0">specs, err := d.GetSpecializationsByVetID(vet.ID)
                if err == nil </span><span class="cov0" title="0">{
                        vet.Specializations = specs
                }</span>

                <span class="cov0" title="0">veterinarians = append(veterinarians, &amp;vet)</span>
        }

        <span class="cov0" title="0">return veterinarians, nil</span>
}

// GetSpecializationsByVetID возвращает специализации врача
func (d *Database) GetSpecializationsByVetID(vetID int) ([]*models.Specialization, error) <span class="cov0" title="0">{
        query := `
                SELECT s.id, s.name, s.description, s.created_at
                FROM specializations s
                INNER JOIN vet_specializations vs ON s.id = vs.specialization_id
                WHERE vs.vet_id = $1
                ORDER BY s.name`

        rows, err := d.db.Query(query, vetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var specializations []*models.Specialization
        for rows.Next() </span><span class="cov0" title="0">{
                var spec models.Specialization
                err := rows.Scan(&amp;spec.ID, &amp;spec.Name, &amp;spec.Description, &amp;spec.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">specializations = append(specializations, &amp;spec)</span>
        }

        <span class="cov0" title="0">return specializations, nil</span>
}

// GetAllClinics возвращает все клиники
func (d *Database) GetAllClinics() ([]*models.Clinic, error) <span class="cov0" title="0">{
        query := "SELECT id, name, address, phone, working_hours, is_active, created_at FROM clinics ORDER BY name"
        rows, err := d.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var clinics []*models.Clinic
        for rows.Next() </span><span class="cov0" title="0">{
                var clinic models.Clinic
                err := rows.Scan(&amp;clinic.ID, &amp;clinic.Name, &amp;clinic.Address, &amp;clinic.Phone,
                        &amp;clinic.WorkingHours, &amp;clinic.IsActive, &amp;clinic.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clinics = append(clinics, &amp;clinic)</span>
        }

        <span class="cov0" title="0">return clinics, nil</span>
}

// GetSchedulesByVetID возвращает расписание врача
func (d *Database) GetSchedulesByVetID(vetID int) ([]*models.Schedule, error) <span class="cov0" title="0">{
        query := `
                SELECT s.id, s.vet_id, s.clinic_id, s.day_of_week, s.start_time, s.end_time, 
                       s.is_available, s.created_at,
                       c.name, c.address, c.phone, c.working_hours, c.is_active, c.created_at
                FROM schedules s
                LEFT JOIN clinics c ON s.clinic_id = c.id
                WHERE s.vet_id = $1 AND s.is_available = true
                ORDER BY s.day_of_week, s.start_time`

        rows, err := d.db.Query(query, vetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var schedules []*models.Schedule
        for rows.Next() </span><span class="cov0" title="0">{
                var schedule models.Schedule
                var clinic models.Clinic
                var clinicPhone, clinicWorkingHours sql.NullString

                err := rows.Scan(&amp;schedule.ID, &amp;schedule.VetID, &amp;schedule.ClinicID, &amp;schedule.DayOfWeek,
                        &amp;schedule.StartTime, &amp;schedule.EndTime, &amp;schedule.IsAvailable, &amp;schedule.CreatedAt,
                        &amp;clinic.Name, &amp;clinic.Address, &amp;clinicPhone, &amp;clinicWorkingHours, &amp;clinic.IsActive, &amp;clinic.CreatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">clinic.Phone = clinicPhone
                clinic.WorkingHours = clinicWorkingHours
                schedule.Clinic = &amp;clinic
                schedules = append(schedules, &amp;schedule)</span>
        }

        <span class="cov0" title="0">return schedules, nil</span>
}

// FindAvailableVets ищет доступных врачей по критериям
func (d *Database) FindAvailableVets(criteria *models.SearchCriteria) ([]*models.Veterinarian, error) <span class="cov0" title="0">{
        query := `
                SELECT DISTINCT v.id, v.first_name, v.last_name, v.phone, v.email, 
                       v.description, v.experience_years, v.is_active, v.created_at
                FROM veterinarians v
                LEFT JOIN vet_specializations vs ON v.id = vs.vet_id
                LEFT JOIN schedules s ON v.id = s.vet_id
                WHERE v.is_active = true AND s.is_available = true`

        args := []interface{}{}
        argCount := 0

        if criteria.SpecializationID &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND vs.specialization_id = $%d", argCount)
                args = append(args, criteria.SpecializationID)
        }</span>

        <span class="cov0" title="0">if criteria.DayOfWeek &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND s.day_of_week = $%d", argCount)
                args = append(args, criteria.DayOfWeek)
        }</span>

        <span class="cov0" title="0">if criteria.ClinicID &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND s.clinic_id = $%d", argCount)
                args = append(args, criteria.ClinicID)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY v.first_name, v.last_name"

        rows, err := d.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var veterinarians []*models.Veterinarian
        for rows.Next() </span><span class="cov0" title="0">{
                var vet models.Veterinarian
                err := rows.Scan(&amp;vet.ID, &amp;vet.FirstName, &amp;vet.LastName, &amp;vet.Phone, &amp;vet.Email,
                        &amp;vet.Description, &amp;vet.ExperienceYears, &amp;vet.IsActive, &amp;vet.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Загружаем специализации для каждого врача
                <span class="cov0" title="0">specs, err := d.GetSpecializationsByVetID(vet.ID)
                if err == nil </span><span class="cov0" title="0">{
                        vet.Specializations = specs
                }</span>

                <span class="cov0" title="0">veterinarians = append(veterinarians, &amp;vet)</span>
        }

        <span class="cov0" title="0">return veterinarians, nil</span>
}

// ========== НОВЫЕ МЕТОДЫ ДЛЯ АДМИНКИ ==========

// GetAllVeterinarians возвращает всех врачей
func (d *Database) GetAllVeterinarians() ([]*models.Veterinarian, error) <span class="cov0" title="0">{
        query := `SELECT id, first_name, last_name, phone, email, description, experience_years, is_active, created_at 
              FROM veterinarians ORDER BY first_name, last_name`

        rows, err := d.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var vets []*models.Veterinarian
        for rows.Next() </span><span class="cov0" title="0">{
                var vet models.Veterinarian
                err := rows.Scan(&amp;vet.ID, &amp;vet.FirstName, &amp;vet.LastName, &amp;vet.Phone, &amp;vet.Email,
                        &amp;vet.Description, &amp;vet.ExperienceYears, &amp;vet.IsActive, &amp;vet.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vets = append(vets, &amp;vet)</span>
        }

        <span class="cov0" title="0">return vets, nil</span>
}

// GetVeterinarianByID возвращает врача по ID
func (d *Database) GetVeterinarianByID(id int) (*models.Veterinarian, error) <span class="cov0" title="0">{
        query := `SELECT id, first_name, last_name, phone, email, description, experience_years, is_active, created_at 
              FROM veterinarians WHERE id = $1`

        var vet models.Veterinarian
        err := d.db.QueryRow(query, id).Scan(&amp;vet.ID, &amp;vet.FirstName, &amp;vet.LastName, &amp;vet.Phone,
                &amp;vet.Email, &amp;vet.Description, &amp;vet.ExperienceYears,
                &amp;vet.IsActive, &amp;vet.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;vet, nil</span>
}

// GetClinicByID возвращает клинику по ID
func (d *Database) GetClinicByID(id int) (*models.Clinic, error) <span class="cov0" title="0">{
        query := `SELECT id, name, address, phone, working_hours, is_active, created_at 
              FROM clinics WHERE id = $1`

        var clinic models.Clinic
        err := d.db.QueryRow(query, id).Scan(&amp;clinic.ID, &amp;clinic.Name, &amp;clinic.Address,
                &amp;clinic.Phone, &amp;clinic.WorkingHours, &amp;clinic.IsActive,
                &amp;clinic.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;clinic, nil</span>
}

func (d *Database) AddMissingColumns() error <span class="cov0" title="0">{
        // Добавляем is_active в clinics если не существует
        _, err := d.db.Exec(`
                DO $$ 
                BEGIN 
                        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                                                  WHERE table_name = 'clinics' AND column_name = 'is_active') THEN
                                ALTER TABLE clinics ADD COLUMN is_active BOOLEAN DEFAULT TRUE;
                        END IF;
                END $$;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Добавляем is_active в veterinarians если не существует
        <span class="cov0" title="0">_, err = d.db.Exec(`
                DO $$ 
                BEGIN 
                        IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                                                  WHERE table_name = 'veterinarians' AND column_name = 'is_active') THEN
                                ALTER TABLE veterinarians ADD COLUMN is_active BOOLEAN DEFAULT TRUE;
                        END IF;
                END $$;
        `)
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
        "os"

        "github.com/drerr0r/vetbot/internal/models"
)

// TestConfig содержит конфигурацию для тестов базы данных
type TestConfig struct {
        DatabaseURL string
        UseTestDB   bool
}

// GetTestConfig возвращает конфигурацию для тестов
func GetTestConfig() *TestConfig <span class="cov8" title="1">{
        return &amp;TestConfig{
                DatabaseURL: getTestDatabaseURL(),
                UseTestDB:   os.Getenv("USE_TEST_DB") == "true",
        }
}</span>

func getTestDatabaseURL() string <span class="cov8" title="1">{
        if url := os.Getenv("TEST_DATABASE_URL"); url != "" </span><span class="cov0" title="0">{
                return url
        }</span>
        <span class="cov8" title="1">return "postgres://vetbot_user:vetbot_password@localhost:5432/vetbot_test?sslmode=disable"</span>
}

// SetupTestDatabase создает тестовую базу данных
func SetupTestDatabase(t testingT, config *TestConfig) *Database <span class="cov8" title="1">{
        if !config.UseTestDB </span><span class="cov8" title="1">{
                t.Skip("Skipping database test - set USE_TEST_DB=true to enable")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := New(config.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                t.Skipf("Skipping test: cannot connect to database: %v", err)
                return nil
        }</span>

        // Создаем тестовые таблицы если их нет
        <span class="cov0" title="0">if err := createTestTables(db.GetDB()); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to setup test database: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

// testingT это минимальный интерфейс для testing.T
type testingT interface {
        Skip(args ...interface{})
        Skipf(format string, args ...interface{})
        Fatalf(format string, args ...interface{})
}

// createTestTables создает тестовые таблицы
func createTestTables(db *sql.DB) error <span class="cov0" title="0">{
        queries := []string{
                // Таблица пользователей
                `CREATE TABLE IF NOT EXISTS users (
                        id SERIAL PRIMARY KEY,
                        telegram_id BIGINT UNIQUE NOT NULL,
                        username TEXT,
                        first_name TEXT,
                        last_name TEXT,
                        phone TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,

                // Таблица специализаций
                `CREATE TABLE IF NOT EXISTS specializations (
                        id SERIAL PRIMARY KEY,
                        name TEXT NOT NULL,
                        description TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,

                // Таблица врачей
                `CREATE TABLE IF NOT EXISTS veterinarians (
                        id SERIAL PRIMARY KEY,
                        first_name TEXT NOT NULL,
                        last_name TEXT NOT NULL,
                        phone TEXT NOT NULL,
                        email TEXT,
                        description TEXT,
                        experience_years INTEGER,
                        is_active BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,

                // Таблица клиник
                `CREATE TABLE IF NOT EXISTS clinics (
                        id SERIAL PRIMARY KEY,
                        name TEXT NOT NULL,
                        address TEXT NOT NULL,
                        phone TEXT,
                        working_hours TEXT,
                        is_active BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,

                // Таблица связей врачей и специализаций
                `CREATE TABLE IF NOT EXISTS vet_specializations (
                        vet_id INTEGER REFERENCES veterinarians(id),
                        specialization_id INTEGER REFERENCES specializations(id),
                        PRIMARY KEY (vet_id, specialization_id)
                )`,

                // Таблица расписания
                `CREATE TABLE IF NOT EXISTS schedules (
                        id SERIAL PRIMARY KEY,
                        vet_id INTEGER REFERENCES veterinarians(id),
                        clinic_id INTEGER REFERENCES clinics(id),
                        day_of_week INTEGER NOT NULL,
                        start_time TEXT NOT NULL,
                        end_time TEXT NOT NULL,
                        is_available BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )`,

                // Вставляем тестовые данные
                `INSERT INTO specializations (id, name, description) VALUES 
                        (1, 'Хирург', 'Ветеринарный хирург'),
                        (2, 'Терапевт', 'Ветеринарный терапевт'),
                        (3, 'Дерматолог', 'Ветеринарный дерматолог')
                ON CONFLICT (id) DO NOTHING`,

                `INSERT INTO veterinarians (id, first_name, last_name, phone, is_active) VALUES 
                        (1, 'Иван', 'Петров', '+79123456789', true),
                        (2, 'Анна', 'Смирнова', '+79123456780', true)
                ON CONFLICT (id) DO NOTHING`,

                `INSERT INTO clinics (id, name, address, is_active) VALUES 
                        (1, 'ВетКлиника Центр', 'ул. Центральная, 1', true),
                        (2, 'ВетКлиника Север', 'ул. Северная, 2', true)
                ON CONFLICT (id) DO NOTHING`,

                `INSERT INTO vet_specializations (vet_id, specialization_id) VALUES 
                        (1, 1), (1, 2), (2, 3)
                ON CONFLICT DO NOTHING`,

                `INSERT INTO schedules (vet_id, clinic_id, day_of_week, start_time, end_time) VALUES 
                        (1, 1, 1, '09:00', '18:00'),
                        (1, 1, 3, '09:00', '18:00'),
                        (2, 2, 2, '10:00', '19:00')
                ON CONFLICT DO NOTHING`,
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute query: %v\nQuery: %s", err, query)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CleanupTestDatabase очищает тестовые данные
func CleanupTestDatabase(db *Database) <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">queries := []string{
                "DELETE FROM schedules",
                "DELETE FROM vet_specializations",
                "DELETE FROM veterinarians",
                "DELETE FROM clinics",
                "DELETE FROM specializations",
                "DELETE FROM users",
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.GetDB().Exec(query); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to cleanup: %v", err)
                }</span>
        }
}

// CreateTestUser создает тестового пользователя
func CreateTestUser(db *Database, telegramID int64) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{
                TelegramID: telegramID,
                Username:   fmt.Sprintf("testuser_%d", telegramID),
                FirstName:  "Test",
                LastName:   "User",
                Phone:      "+79123456789",
        }

        err := db.CreateUser(user)
        return user, err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// TelegramBotAdapter адаптер для реального tgbotapi.BotAPI
type TelegramBotAdapter struct {
        bot *tgbotapi.BotAPI
}

// NewTelegramBotAdapter создает новый адаптер
func NewTelegramBotAdapter(bot *tgbotapi.BotAPI) *TelegramBotAdapter <span class="cov0" title="0">{
        return &amp;TelegramBotAdapter{bot: bot}
}</span>

// Send отправляет сообщение
func (a *TelegramBotAdapter) Send(c tgbotapi.Chattable) (tgbotapi.Message, error) <span class="cov0" title="0">{
        return a.bot.Send(c)
}</span>

// Request выполняет запрос к API
func (a *TelegramBotAdapter) Request(c tgbotapi.Chattable) (*tgbotapi.APIResponse, error) <span class="cov0" title="0">{
        return a.bot.Request(c)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "fmt"
        "log"
        "sort"
        "strconv"
        "strings"

        "github.com/drerr0r/vetbot/internal/models"
        "github.com/drerr0r/vetbot/pkg/utils"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// AdminHandlers содержит обработчики для административных функций
type AdminHandlers struct {
        bot        BotAPI   // Используем интерфейс
        db         Database // Используем интерфейс
        config     *utils.Config
        adminState map[int64]string
        tempData   map[string]interface{} // Добавляем недостающее поле
}

// NewAdminHandlers создает новый экземпляр AdminHandlers
func NewAdminHandlers(bot BotAPI, db Database, config *utils.Config) *AdminHandlers <span class="cov8" title="1">{
        return &amp;AdminHandlers{
                bot:        bot,
                db:         db,
                config:     config,
                adminState: make(map[int64]string),
                tempData:   make(map[string]interface{}), // Инициализируем
        }
}</span>

// HandleAdmin показывает админскую панель
func (h *AdminHandlers) HandleAdmin(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "main_menu"

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("👥 Управление врачами"),
                        tgbotapi.NewKeyboardButton("🏥 Управление клиниками"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("📊 Статистика"),
                        tgbotapi.NewKeyboardButton("⚙️ Настройки"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("❌ Выйти из админки"),
                ),
        )
        keyboard.OneTimeKeyboard = true

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                "🔧 *Административная панель*\n\nВыберите раздел для управления:")
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)
}</span>

// HandleAdminMessage обрабатывает текстовые сообщения в админском режиме
func (h *AdminHandlers) HandleAdminMessage(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        text := update.Message.Text
        state := h.adminState[userID]

        log.Printf("Admin message from %d: %s (state: %s)", userID, text, state)

        // Сначала проверяем кнопку "Назад" независимо от состояния
        if text == "🔙 Назад" </span><span class="cov0" title="0">{
                h.handleBackButton(update)
                return
        }</span>

        <span class="cov0" title="0">switch state </span>{
        case "main_menu":<span class="cov0" title="0">
                h.handleMainMenu(update, text)</span>
        case "vet_management":<span class="cov0" title="0">
                h.handleVetManagement(update, text)</span>
        case "clinic_management":<span class="cov0" title="0">
                h.handleClinicManagement(update, text)</span>
        case "add_vet_name":<span class="cov0" title="0">
                h.handleAddVetName(update, text)</span>
        case "add_vet_phone":<span class="cov0" title="0">
                h.handleAddVetPhone(update, text)</span>
        case "add_vet_specializations":<span class="cov0" title="0">
                h.handleAddVetSpecializations(update, text)</span>
        case "vet_list":<span class="cov0" title="0">
                h.handleVetListSelection(update, text)</span>
        case "vet_edit_menu":<span class="cov0" title="0">
                h.handleVetEditMenu(update, text)</span>
        case "vet_edit_field":<span class="cov0" title="0">
                h.handleVetEditField(update, text)</span>
        case "vet_edit_specializations":<span class="cov0" title="0">
                h.handleVetEditSpecializations(update, text)</span>
        case "vet_confirm_delete":<span class="cov0" title="0">
                h.handleVetConfirmDelete(update, text)</span>
        case "vet_toggle_active":<span class="cov0" title="0">
                h.handleVetToggleActive(update, text)</span>
        case "clinic_list":<span class="cov0" title="0">
                h.handleClinicListSelection(update, text)</span>
        case "clinic_edit_menu":<span class="cov0" title="0">
                h.handleClinicEditMenu(update, text)</span>
        case "clinic_edit_field":<span class="cov0" title="0">
                h.handleClinicEditField(update, text)</span>
        case "clinic_confirm_delete":<span class="cov0" title="0">
                h.handleClinicConfirmDelete(update, text)</span>
        case "clinic_toggle_active":<span class="cov0" title="0">
                h.handleClinicToggleActive(update, text)</span>
        default:<span class="cov0" title="0">
                h.handleMainMenu(update, text)</span>
        }
}

// handleBackButton обрабатывает кнопку "Назад"
func (h *AdminHandlers) handleBackButton(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        currentState := h.adminState[userID]

        // Определяем текущее состояние и возвращаемся на уровень выше
        switch currentState </span>{
        case "vet_management", "clinic_management":<span class="cov0" title="0">
                // Возврат из подменю в главное меню
                h.adminState[userID] = "main_menu"
                h.HandleAdmin(update)</span>
        case "vet_list", "vet_edit_menu", "vet_edit_field", "vet_edit_specializations", "vet_confirm_delete", "vet_toggle_active":<span class="cov0" title="0">
                // Возврат из операций с врачами в меню управления врачами
                h.adminState[userID] = "vet_management"
                h.showVetManagement(update)</span>
        case "clinic_list", "clinic_edit_menu", "clinic_edit_field", "clinic_confirm_delete", "clinic_toggle_active":<span class="cov0" title="0">
                // Возврат из операций с клиниками в меню управления клиниками
                h.adminState[userID] = "clinic_management"
                h.showClinicManagement(update)</span>
        case "add_vet_name", "add_vet_phone", "add_vet_specializations":<span class="cov0" title="0">
                // Возврат из процесса добавления врача в меню управления врачами
                h.adminState[userID] = "vet_management"
                h.cleanTempData(userID)
                h.showVetManagement(update)</span>
        default:<span class="cov0" title="0">
                // По умолчанию возвращаем в главное меню
                h.adminState[userID] = "main_menu"
                h.HandleAdmin(update)</span>
        }
}

// cleanTempData очищает временные данные пользователя
func (h *AdminHandlers) cleanTempData(userID int64) <span class="cov0" title="0">{
        userIDStr := strconv.FormatInt(userID, 10)
        delete(h.tempData, userIDStr+"_name")
        delete(h.tempData, userIDStr+"_phone")
        delete(h.tempData, userIDStr+"_vet_edit")
        delete(h.tempData, userIDStr+"_clinic_edit")
}</span>

// handleMainMenu обрабатывает главное меню админки
func (h *AdminHandlers) handleMainMenu(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        switch text </span>{
        case "👥 Управление врачами":<span class="cov0" title="0">
                h.showVetManagement(update)</span>
        case "🏥 Управление клиниками":<span class="cov0" title="0">
                h.showClinicManagement(update)</span>
        case "📊 Статистика":<span class="cov0" title="0">
                h.HandleStats(update)</span>
        case "⚙️ Настройки":<span class="cov0" title="0">
                h.showSettings(update)</span>
        case "❌ Выйти из админки":<span class="cov0" title="0">
                h.closeAdmin(update)</span>
        default:<span class="cov0" title="0">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Используйте кнопки админской панели")
                h.bot.Send(msg)</span>
        }
}

// handleVetManagement обрабатывает меню управления врачами
func (h *AdminHandlers) handleVetManagement(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        switch text </span>{
        case "➕ Добавить врача":<span class="cov0" title="0">
                h.startAddVet(update)</span>
        case "📋 Список врачей":<span class="cov0" title="0">
                h.showVetList(update)</span>
        case "🔙 Назад":<span class="cov0" title="0">
                h.handleBackButton(update)</span>
        default:<span class="cov0" title="0">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Используйте кнопки меню управления врачами")
                h.bot.Send(msg)</span>
        }
}

// handleClinicManagement обрабатывает меню управления клиниками
func (h *AdminHandlers) handleClinicManagement(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        switch text </span>{
        case "➕ Добавить клинику":<span class="cov0" title="0">
                h.startAddClinic(update)</span>
        case "📋 Список клиник":<span class="cov0" title="0">
                h.showClinicList(update)</span>
        case "🔙 Назад":<span class="cov0" title="0">
                h.handleBackButton(update)</span>
        default:<span class="cov0" title="0">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Используйте кнопки меню управления клиниками")
                h.bot.Send(msg)</span>
        }
}

// showVetManagement показывает меню управления врачами
func (h *AdminHandlers) showVetManagement(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "vet_management"

        // Получаем статистику врачей
        activeVets, _ := h.getActiveVetCount()
        totalVets, _ := h.getTotalVetCount()

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("➕ Добавить врача"),
                        tgbotapi.NewKeyboardButton("📋 Список врачей"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                fmt.Sprintf("👥 *Управление врачами*\n\nАктивных врачей: %d/%d\n\nВыберите действие:", activeVets, totalVets))
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)
}</span>

// showClinicManagement показывает меню управления клиниками
func (h *AdminHandlers) showClinicManagement(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "clinic_management"

        // Получаем статистику клиник
        activeClinics, _ := h.getActiveClinicCount()
        totalClinics, _ := h.getTotalClinicCount()

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("➕ Добавить клинику"),
                        tgbotapi.NewKeyboardButton("📋 Список клиник"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                fmt.Sprintf("🏥 *Управление клиниками*\n\nАктивных клиник: %d/%d\n\nВыберите действие:", activeClinics, totalClinics))
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)
}</span>

// startAddVet начинает процесс добавления врача
func (h *AdminHandlers) startAddVet(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "add_vet_name"

        removeKeyboard := tgbotapi.NewRemoveKeyboard(true)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                "👨‍⚕️ *Добавление нового врача*\n\nВведите имя врача:")
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = removeKeyboard

        h.bot.Send(msg)
}</span>

// handleAddVetName обрабатывает ввод имени врача
func (h *AdminHandlers) handleAddVetName(update tgbotapi.Update, name string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "add_vet_phone"

        // Сохраняем имя во временное хранилище
        userIDStr := strconv.FormatInt(userID, 10)
        h.tempData[userIDStr+"_name"] = name

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                "📞 Теперь введите телефон врача:")
        msg.ParseMode = "Markdown"

        h.bot.Send(msg)
}</span>

// handleAddVetPhone обрабатывает ввод телефона врача
func (h *AdminHandlers) handleAddVetPhone(update tgbotapi.Update, phone string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "add_vet_specializations"

        // Сохраняем телефон
        userIDStr := strconv.FormatInt(userID, 10)
        h.tempData[userIDStr+"_phone"] = phone

        // Получаем список специализаций для выбора
        specializations, err := h.db.GetAllSpecializations()
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Ошибка при получении специализаций")
                h.bot.Send(msg)
                return
        }</span>

        // Сортируем специализации по ID для предсказуемости
        <span class="cov0" title="0">sort.Slice(specializations, func(i, j int) bool </span><span class="cov0" title="0">{
                return specializations[i].ID &lt; specializations[j].ID
        }</span>)

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("🎯 Выберите специализации врача (введите ID через запятую):\n\n")

        for _, spec := range specializations </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("ID %d: %s\n", spec.ID, spec.Name))
        }</span>

        <span class="cov0" title="0">sb.WriteString("\nПример: 1,3,5")

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
        h.bot.Send(msg)</span>
}

// handleAddVetSpecializations обрабатывает ввод специализаций
func (h *AdminHandlers) handleAddVetSpecializations(update tgbotapi.Update, specsText string) <span class="cov0" title="0">{
        userID := update.Message.From.ID

        // Получаем сохраненные данные
        userIDStr := strconv.FormatInt(userID, 10)
        name := h.getStringTempData(userIDStr + "_name")
        phone := h.getStringTempData(userIDStr + "_phone")

        if name == "" || phone == "" </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Ошибка: данные врача не найдены. Начните заново.")
                h.bot.Send(msg)
                h.startAddVet(update)
                return
        }</span>

        // Валидация введенных ID специализаций
        <span class="cov0" title="0">if !h.isValidSpecializationIDs(specsText) </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "❌ Неверный формат ID специализаций. Введите существующие ID через запятую (например: 1,3,5)")
                h.bot.Send(msg)
                return
        }</span>

        // Создаем врача
        <span class="cov0" title="0">vet := &amp;models.Veterinarian{
                FirstName: name,
                LastName:  "", // Можно добавить поле для фамилии
                Phone:     phone,
                IsActive:  true,
        }

        // Добавляем врача в базу
        err := h.addVeterinarian(vet, specsText)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Ошибка при добавлении врача: %v", err))
                h.bot.Send(msg)
        }</span> else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "✅ Врач успешно добавлен!")
                h.bot.Send(msg)
        }</span>

        // Очищаем временные данные
        <span class="cov0" title="0">h.cleanTempData(userID)

        // Возвращаем в меню управления врачами
        h.adminState[userID] = "vet_management"
        h.showVetManagement(update)</span>
}

// showVetList показывает список врачей с возможностью выбора
func (h *AdminHandlers) showVetList(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "vet_list"

        vets, err := h.db.GetAllVeterinarians()
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении списка врачей")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">if len(vets) == 0 </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Врачи не найдены")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("👥 *Список врачей:*\n\n")

        for i, vet := range vets </span><span class="cov0" title="0">{
                status := "✅"
                if !vet.IsActive </span><span class="cov0" title="0">{
                        status = "❌"
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%s %d. %s %s - %s\n", status, i+1, vet.FirstName, vet.LastName, vet.Phone))</span>
        }

        <span class="cov0" title="0">sb.WriteString("\nВведите номер врача для управления:")

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)</span>
}

// handleVetListSelection обрабатывает выбор врача из списка
func (h *AdminHandlers) handleVetListSelection(update tgbotapi.Update, text string) <span class="cov0" title="0">{

        // Парсим номер врача
        index, err := strconv.Atoi(text)
        if err != nil || index &lt; 1 </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите корректный номер врача")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">vets, err := h.db.GetAllVeterinarians()
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении списка врачей")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">if index &gt; len(vets) </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Врач с таким номером не найден")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">vet := vets[index-1]
        h.showVetEditMenu(update, vet)</span>
}

// showVetEditMenu показывает меню редактирования врача
func (h *AdminHandlers) showVetEditMenu(update tgbotapi.Update, vet *models.Veterinarian) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "vet_edit_menu"

        // Сохраняем ID врача во временные данные
        userIDStr := strconv.FormatInt(userID, 10)
        h.tempData[userIDStr+"_vet_edit"] = &amp;models.VetEditData{
                VetID: vet.ID,
        }

        // Получаем специализации врача
        specs, err := h.db.GetSpecializationsByVetID(vet.ID)
        specsText := ""
        if err == nil &amp;&amp; len(specs) &gt; 0 </span><span class="cov0" title="0">{
                var specIDs []string
                for _, spec := range specs </span><span class="cov0" title="0">{
                        specIDs = append(specIDs, strconv.Itoa(spec.ID))
                }</span>
                <span class="cov0" title="0">specsText = strings.Join(specIDs, ",")</span>
        }

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString(fmt.Sprintf("👨‍⚕️ *Управление врачом:* %s %s\n\n", vet.FirstName, vet.LastName))
        sb.WriteString(fmt.Sprintf("📞 Телефон: %s\n", vet.Phone))

        if vet.Email.Valid </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("📧 Email: %s\n", vet.Email.String))
        }</span>

        <span class="cov0" title="0">if vet.ExperienceYears.Valid </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("💼 Опыт: %d лет\n", vet.ExperienceYears.Int64))
        }</span>

        <span class="cov0" title="0">sb.WriteString("📊 Статус: ")
        if vet.IsActive </span><span class="cov0" title="0">{
                sb.WriteString("✅ Активен\n")
        }</span> else<span class="cov0" title="0"> {
                sb.WriteString("❌ Неактивен\n")
        }</span>

        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("🎯 Специализации: %s\n\n", specsText))
        sb.WriteString("Выберите действие:")

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("✏️ Редактировать имя"),
                        tgbotapi.NewKeyboardButton("📞 Редактировать телефон"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🎯 Редактировать специализации"),
                        tgbotapi.NewKeyboardButton("📧 Редактировать email"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("💼 Редактировать опыт"),
                        tgbotapi.NewKeyboardButton("⚡ Изменить статус"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🗑️ Удалить врача"),
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)</span>
}

// handleVetEditMenu обрабатывает выбор действия для врача
func (h *AdminHandlers) handleVetEditMenu(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        vetData, ok := h.tempData[userIDStr+"_vet_edit"].(*models.VetEditData)
        if !ok || vetData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные врача не найдены")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        // Получаем актуальные данные врача
        <span class="cov0" title="0">vet, err := h.db.GetVeterinarianByID(vetData.VetID)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении данных врача")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        <span class="cov0" title="0">switch text </span>{
        case "✏️ Редактировать имя":<span class="cov0" title="0">
                h.adminState[userID] = "vet_edit_field"
                vetData.Field = "first_name"
                vetData.CurrentValue = vet.FirstName
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новое имя врача:")
                h.bot.Send(msg)</span>

        case "📞 Редактировать телефон":<span class="cov0" title="0">
                h.adminState[userID] = "vet_edit_field"
                vetData.Field = "phone"
                vetData.CurrentValue = vet.Phone
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новый телефон врача:")
                h.bot.Send(msg)</span>

        case "📧 Редактировать email":<span class="cov0" title="0">
                h.adminState[userID] = "vet_edit_field"
                vetData.Field = "email"
                if vet.Email.Valid </span><span class="cov0" title="0">{
                        vetData.CurrentValue = vet.Email.String
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новый email врача (или '-' для очистки):")
                h.bot.Send(msg)</span>

        case "💼 Редактировать опыт":<span class="cov0" title="0">
                h.adminState[userID] = "vet_edit_field"
                vetData.Field = "experience_years"
                if vet.ExperienceYears.Valid </span><span class="cov0" title="0">{
                        vetData.CurrentValue = strconv.FormatInt(vet.ExperienceYears.Int64, 10)
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новый опыт работы в годах (или '-' для очистки):")
                h.bot.Send(msg)</span>

        case "🎯 Редактировать специализации":<span class="cov0" title="0">
                h.adminState[userID] = "vet_edit_specializations"
                specs, err := h.db.GetSpecializationsByVetID(vet.ID)
                if err == nil &amp;&amp; len(specs) &gt; 0 </span><span class="cov0" title="0">{
                        var specIDs []string
                        for _, spec := range specs </span><span class="cov0" title="0">{
                                specIDs = append(specIDs, strconv.Itoa(spec.ID))
                        }</span>
                        <span class="cov0" title="0">vetData.Specializations = strings.Join(specIDs, ",")</span>
                }

                // Показываем список специализаций
                <span class="cov0" title="0">specializations, err := h.db.GetAllSpecializations()
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении специализаций")
                        h.bot.Send(msg)
                        return
                }</span>

                <span class="cov0" title="0">var sb strings.Builder
                sb.WriteString("🎯 Текущие специализации: ")
                if vetData.Specializations != "" </span><span class="cov0" title="0">{
                        sb.WriteString(vetData.Specializations)
                }</span> else<span class="cov0" title="0"> {
                        sb.WriteString("не указаны")
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n\nДоступные специализации:\n")

                for _, spec := range specializations </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("ID %d: %s\n", spec.ID, spec.Name))
                }</span>

                <span class="cov0" title="0">sb.WriteString("\nВведите ID специализаций через запятую (например: 1,3,5):")

                msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
                h.bot.Send(msg)</span>

        case "⚡ Изменить статус":<span class="cov0" title="0">
                h.adminState[userID] = "vet_toggle_active"
                newStatus := !vet.IsActive
                statusText := "активен"
                if !newStatus </span><span class="cov0" title="0">{
                        statusText = "неактивен"
                }</span>

                <span class="cov0" title="0">keyboard := tgbotapi.NewReplyKeyboard(
                        tgbotapi.NewKeyboardButtonRow(
                                tgbotapi.NewKeyboardButton("✅ Подтвердить"),
                                tgbotapi.NewKeyboardButton("❌ Отмена"),
                        ),
                )

                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Вы уверены, что хотите сделать врача %s %s?", vet.FirstName, statusText))
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)</span>

        case "🗑️ Удалить врача":<span class="cov0" title="0">
                h.adminState[userID] = "vet_confirm_delete"
                keyboard := tgbotapi.NewReplyKeyboard(
                        tgbotapi.NewKeyboardButtonRow(
                                tgbotapi.NewKeyboardButton("✅ Подтвердить удаление"),
                                tgbotapi.NewKeyboardButton("❌ Отмена"),
                        ),
                )

                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("⚠️ *ВНИМАНИЕ!* \n\nВы собираетесь удалить врача %s %s.\nЭто действие нельзя отменить!\n\nПодтвердите удаление:", vet.FirstName, vet.LastName))
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)</span>

        case "🔙 Назад":<span class="cov0" title="0">
                h.handleBackButton(update)</span>

        default:<span class="cov0" title="0">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Используйте кнопки для управления")
                h.bot.Send(msg)</span>
        }
}

// handleVetEditField обрабатывает ввод нового значения для поля врача
func (h *AdminHandlers) handleVetEditField(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        vetData, ok := h.tempData[userIDStr+"_vet_edit"].(*models.VetEditData)
        if !ok || vetData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные врача не найдены")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        // Обработка специальных значений
        <span class="cov0" title="0">if text == "-" </span><span class="cov0" title="0">{
                text = "" // Очистка поля
        }</span>

        // Обновляем поле в базе данных
        <span class="cov0" title="0">err := h.updateVeterinarianField(vetData.VetID, vetData.Field, text)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Ошибка при обновлении данных: %v", err))
                h.bot.Send(msg)
        }</span> else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "✅ Данные успешно обновлены!")
                h.bot.Send(msg)
        }</span>

        // Возвращаем в меню редактирования врача
        <span class="cov0" title="0">vet, err := h.db.GetVeterinarianByID(vetData.VetID)
        if err == nil </span><span class="cov0" title="0">{
                h.showVetEditMenu(update, vet)
        }</span> else<span class="cov0" title="0"> {
                h.showVetList(update)
        }</span>
}

// handleVetEditSpecializations обрабатывает ввод специализаций врача
func (h *AdminHandlers) handleVetEditSpecializations(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        vetData, ok := h.tempData[userIDStr+"_vet_edit"].(*models.VetEditData)
        if !ok || vetData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные врача не найдены")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        // Валидация ID специализаций
        <span class="cov0" title="0">if text != "" &amp;&amp; !h.isValidSpecializationIDs(text) </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "❌ Неверный формат ID специализаций. Введите существующие ID через запятую")
                h.bot.Send(msg)
                return
        }</span>

        // Обновляем специализации врача
        <span class="cov0" title="0">err := h.updateVeterinarianSpecializations(vetData.VetID, text)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Ошибка при обновлении специализаций: %v", err))
                h.bot.Send(msg)
        }</span> else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "✅ Специализации успешно обновлены!")
                h.bot.Send(msg)
        }</span>

        // Возвращаем в меню редактирования врача
        <span class="cov0" title="0">vet, err := h.db.GetVeterinarianByID(vetData.VetID)
        if err == nil </span><span class="cov0" title="0">{
                h.showVetEditMenu(update, vet)
        }</span> else<span class="cov0" title="0"> {
                h.showVetList(update)
        }</span>
}

// handleVetConfirmDelete обрабатывает подтверждение удаления врача
func (h *AdminHandlers) handleVetConfirmDelete(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        vetData, ok := h.tempData[userIDStr+"_vet_edit"].(*models.VetEditData)
        if !ok || vetData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные врача не найдены")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        <span class="cov0" title="0">if text == "✅ Подтвердить удаление" </span><span class="cov0" title="0">{
                err := h.deleteVeterinarian(vetData.VetID)
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("Ошибка при удалении врача: %v", err))
                        h.bot.Send(msg)
                }</span> else<span class="cov0" title="0"> {
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "✅ Врач успешно удален!")
                        h.bot.Send(msg)
                }</span>
        } else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Удаление отменено")
                h.bot.Send(msg)
        }</span>

        // Возвращаем к списку врачей
        <span class="cov0" title="0">h.showVetList(update)</span>
}

// handleVetToggleActive обрабатывает изменение статуса врача
func (h *AdminHandlers) handleVetToggleActive(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        vetData, ok := h.tempData[userIDStr+"_vet_edit"].(*models.VetEditData)
        if !ok || vetData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные врача не найдены")
                h.bot.Send(msg)
                h.showVetList(update)
                return
        }</span>

        <span class="cov0" title="0">if text == "✅ Подтвердить" </span><span class="cov0" title="0">{
                // Получаем текущего врача
                vet, err := h.db.GetVeterinarianByID(vetData.VetID)
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении данных врача")
                        h.bot.Send(msg)
                        h.showVetList(update)
                        return
                }</span>

                // Меняем статус
                <span class="cov0" title="0">newStatus := !vet.IsActive
                err = h.updateVeterinarianField(vetData.VetID, "is_active", strconv.FormatBool(newStatus))
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("Ошибка при изменении статуса: %v", err))
                        h.bot.Send(msg)
                }</span> else<span class="cov0" title="0"> {
                        statusText := "активен"
                        if !newStatus </span><span class="cov0" title="0">{
                                statusText = "неактивен"
                        }</span>
                        <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("✅ Статус врача изменен на: %s", statusText))
                        h.bot.Send(msg)</span>
                }
        } else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Изменение статуса отменено")
                h.bot.Send(msg)
        }</span>

        // Возвращаем в меню редактирования врача
        <span class="cov0" title="0">vet, err := h.db.GetVeterinarianByID(vetData.VetID)
        if err == nil </span><span class="cov0" title="0">{
                h.showVetEditMenu(update, vet)
        }</span> else<span class="cov0" title="0"> {
                h.showVetList(update)
        }</span>
}

// showClinicList показывает список клиник с возможностью выбора
func (h *AdminHandlers) showClinicList(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "clinic_list"

        clinics, err := h.db.GetAllClinics()
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении списка клиник")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">if len(clinics) == 0 </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Клиники не найдены")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("🏥 *Список клиник:*\n\n")

        for i, clinic := range clinics </span><span class="cov0" title="0">{
                status := "✅"
                if !clinic.IsActive </span><span class="cov0" title="0">{
                        status = "❌"
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%s %d. %s - %s\n", status, i+1, clinic.Name, clinic.Address))</span>
        }

        <span class="cov0" title="0">sb.WriteString("\nВведите номер клиники для управления:")

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)</span>
}

// handleClinicListSelection обрабатывает выбор клиники из списка
func (h *AdminHandlers) handleClinicListSelection(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        // Парсим номер клиники
        index, err := strconv.Atoi(text)
        if err != nil || index &lt; 1 </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите корректный номер клиники")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">clinics, err := h.db.GetAllClinics()
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении списка клиник")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">if index &gt; len(clinics) </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Клиника с таким номером не найдена")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov0" title="0">clinic := clinics[index-1]
        h.showClinicEditMenu(update, clinic)</span>
}

// showClinicEditMenu показывает меню редактирования клиники
func (h *AdminHandlers) showClinicEditMenu(update tgbotapi.Update, clinic *models.Clinic) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        h.adminState[userID] = "clinic_edit_menu"

        // Сохраняем ID клиники во временные данные
        userIDStr := strconv.FormatInt(userID, 10)
        h.tempData[userIDStr+"_clinic_edit"] = &amp;models.ClinicEditData{
                ClinicID: clinic.ID,
        }

        var sb strings.Builder
        sb.WriteString(fmt.Sprintf("🏥 *Управление клиникой:* %s\n\n", clinic.Name))
        sb.WriteString(fmt.Sprintf("📍 Адрес: %s\n", clinic.Address))

        if clinic.Phone.Valid </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("📞 Телефон: %s\n", clinic.Phone.String))
        }</span>

        <span class="cov0" title="0">if clinic.WorkingHours.Valid </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("🕐 Часы работы: %s\n", clinic.WorkingHours.String))
        }</span>

        <span class="cov0" title="0">sb.WriteString("📊 Статус: ")
        if clinic.IsActive </span><span class="cov0" title="0">{
                sb.WriteString("✅ Активна\n")
        }</span> else<span class="cov0" title="0"> {
                sb.WriteString("❌ Неактивна\n")
        }</span>

        <span class="cov0" title="0">sb.WriteString("\nВыберите действие:")

        keyboard := tgbotapi.NewReplyKeyboard(
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("✏️ Редактировать название"),
                        tgbotapi.NewKeyboardButton("📍 Редактировать адрес"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("📞 Редактировать телефон"),
                        tgbotapi.NewKeyboardButton("🕐 Редактировать часы работы"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("⚡ Изменить статус"),
                        tgbotapi.NewKeyboardButton("🗑️ Удалить клинику"),
                ),
                tgbotapi.NewKeyboardButtonRow(
                        tgbotapi.NewKeyboardButton("🔙 Назад"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, sb.String())
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        h.bot.Send(msg)</span>
}

// handleClinicEditMenu обрабатывает выбор действия для клиники
func (h *AdminHandlers) handleClinicEditMenu(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        clinicData, ok := h.tempData[userIDStr+"_clinic_edit"].(*models.ClinicEditData)
        if !ok || clinicData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные клиники не найдены")
                h.bot.Send(msg)
                h.showClinicList(update)
                return
        }</span>

        // Получаем актуальные данные клиники
        <span class="cov0" title="0">clinic, err := h.db.GetClinicByID(clinicData.ClinicID)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении данных клиники")
                h.bot.Send(msg)
                h.showClinicList(update)
                return
        }</span>

        <span class="cov0" title="0">switch text </span>{
        case "✏️ Редактировать название":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_edit_field"
                clinicData.Field = "name"
                clinicData.CurrentValue = clinic.Name
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новое название клиники:")
                h.bot.Send(msg)</span>

        case "📍 Редактировать адрес":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_edit_field"
                clinicData.Field = "address"
                clinicData.CurrentValue = clinic.Address
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новый адрес клиники:")
                h.bot.Send(msg)</span>

        case "📞 Редактировать телефон":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_edit_field"
                clinicData.Field = "phone"
                if clinic.Phone.Valid </span><span class="cov0" title="0">{
                        clinicData.CurrentValue = clinic.Phone.String
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новый телефон клиники (или '-' для очистки):")
                h.bot.Send(msg)</span>

        case "🕐 Редактировать часы работы":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_edit_field"
                clinicData.Field = "working_hours"
                if clinic.WorkingHours.Valid </span><span class="cov0" title="0">{
                        clinicData.CurrentValue = clinic.WorkingHours.String
                }</span>
                <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Введите новые часы работы клиники (или '-' для очистки):")
                h.bot.Send(msg)</span>

        case "⚡ Изменить статус":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_toggle_active"
                newStatus := !clinic.IsActive
                statusText := "активна"
                if !newStatus </span><span class="cov0" title="0">{
                        statusText = "неактивна"
                }</span>

                <span class="cov0" title="0">keyboard := tgbotapi.NewReplyKeyboard(
                        tgbotapi.NewKeyboardButtonRow(
                                tgbotapi.NewKeyboardButton("✅ Подтвердить"),
                                tgbotapi.NewKeyboardButton("❌ Отмена"),
                        ),
                )

                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Вы уверены, что хотите сделать клинику %s %s?", clinic.Name, statusText))
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)</span>

        case "🗑️ Удалить клинику":<span class="cov0" title="0">
                h.adminState[userID] = "clinic_confirm_delete"
                keyboard := tgbotapi.NewReplyKeyboard(
                        tgbotapi.NewKeyboardButtonRow(
                                tgbotapi.NewKeyboardButton("✅ Подтвердить удаление"),
                                tgbotapi.NewKeyboardButton("❌ Отмена"),
                        ),
                )

                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("⚠️ *ВНИМАНИЕ!* \n\nВы собираетесь удалить клинику %s.\nЭто действие нельзя отменить!\n\nПодтвердите удаление:", clinic.Name))
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)</span>

        case "🔙 Назад":<span class="cov0" title="0">
                h.handleBackButton(update)</span>

        default:<span class="cov0" title="0">
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Используйте кнопки для управления")
                h.bot.Send(msg)</span>
        }
}

// handleClinicEditField обрабатывает ввод нового значения для поля клиники
func (h *AdminHandlers) handleClinicEditField(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        clinicData, ok := h.tempData[userIDStr+"_clinic_edit"].(*models.ClinicEditData)
        if !ok || clinicData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные клиники не найдены")
                h.bot.Send(msg)
                h.showClinicList(update)
                return
        }</span>

        // Обработка специальных значений
        <span class="cov0" title="0">if text == "-" </span><span class="cov0" title="0">{
                text = "" // Очистка поля
        }</span>

        // Обновляем поле в базе данных
        <span class="cov0" title="0">err := h.updateClinicField(clinicData.ClinicID, clinicData.Field, text)
        if err != nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        fmt.Sprintf("Ошибка при обновлении данных: %v", err))
                h.bot.Send(msg)
        }</span> else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "✅ Данные успешно обновлены!")
                h.bot.Send(msg)
        }</span>

        // Возвращаем в меню редактирования клиники
        <span class="cov0" title="0">clinic, err := h.db.GetClinicByID(clinicData.ClinicID)
        if err == nil </span><span class="cov0" title="0">{
                h.showClinicEditMenu(update, clinic)
        }</span> else<span class="cov0" title="0"> {
                h.showClinicList(update)
        }</span>
}

// handleClinicConfirmDelete обрабатывает подтверждение удаления клиники
func (h *AdminHandlers) handleClinicConfirmDelete(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        clinicData, ok := h.tempData[userIDStr+"_clinic_edit"].(*models.ClinicEditData)
        if !ok || clinicData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные клиники не найдены")
                h.bot.Send(msg)
                h.showClinicList(update)
                return
        }</span>

        <span class="cov0" title="0">if text == "✅ Подтвердить удаление" </span><span class="cov0" title="0">{
                err := h.deleteClinic(clinicData.ClinicID)
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("Ошибка при удалении клиники: %v", err))
                        h.bot.Send(msg)
                }</span> else<span class="cov0" title="0"> {
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "✅ Клиника успешно удалена!")
                        h.bot.Send(msg)
                }</span>
        } else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Удаление отменено")
                h.bot.Send(msg)
        }</span>

        // Возвращаем к списку клиник
        <span class="cov0" title="0">h.showClinicList(update)</span>
}

// handleClinicToggleActive обрабатывает изменение статуса клиники
func (h *AdminHandlers) handleClinicToggleActive(update tgbotapi.Update, text string) <span class="cov0" title="0">{
        userID := update.Message.From.ID
        userIDStr := strconv.FormatInt(userID, 10)

        clinicData, ok := h.tempData[userIDStr+"_clinic_edit"].(*models.ClinicEditData)
        if !ok || clinicData == nil </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка: данные клиники не найдены")
                h.bot.Send(msg)
                h.showClinicList(update)
                return
        }</span>

        <span class="cov0" title="0">if text == "✅ Подтвердить" </span><span class="cov0" title="0">{
                // Получаем текущую клинику
                clinic, err := h.db.GetClinicByID(clinicData.ClinicID)
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Ошибка при получении данных клиники")
                        h.bot.Send(msg)
                        h.showClinicList(update)
                        return
                }</span>

                // Меняем статус
                <span class="cov0" title="0">newStatus := !clinic.IsActive
                err = h.updateClinicField(clinicData.ClinicID, "is_active", strconv.FormatBool(newStatus))
                if err != nil </span><span class="cov0" title="0">{
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("Ошибка при изменении статуса: %v", err))
                        h.bot.Send(msg)
                }</span> else<span class="cov0" title="0"> {
                        statusText := "активна"
                        if !newStatus </span><span class="cov0" title="0">{
                                statusText = "неактивна"
                        }</span>
                        <span class="cov0" title="0">msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                                fmt.Sprintf("✅ Статус клиники изменен на: %s", statusText))
                        h.bot.Send(msg)</span>
                }
        } else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Изменение статуса отменено")
                h.bot.Send(msg)
        }</span>

        // Возвращаем в меню редактирования клиники
        <span class="cov0" title="0">clinic, err := h.db.GetClinicByID(clinicData.ClinicID)
        if err == nil </span><span class="cov0" title="0">{
                h.showClinicEditMenu(update, clinic)
        }</span> else<span class="cov0" title="0"> {
                h.showClinicList(update)
        }</span>
}

// startAddClinic начинает процесс добавления клиники
func (h *AdminHandlers) startAddClinic(update tgbotapi.Update) <span class="cov0" title="0">{
        // TODO: Реализовать добавление клиники
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Функция добавления клиники в разработке")
        h.bot.Send(msg)
}</span>

// showSettings показывает настройки
func (h *AdminHandlers) showSettings(update tgbotapi.Update) <span class="cov0" title="0">{
        userCount, _ := h.getUserCount()
        activeVets, _ := h.getActiveVetCount()
        totalVets, _ := h.getTotalVetCount()
        activeClinics, _ := h.getActiveClinicCount()
        totalClinics, _ := h.getTotalClinicCount()

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                fmt.Sprintf(`⚙️ *Настройки системы*

📊 Статистика:
• Пользователей: %d
• Врачей: %d/%d активных
• Клиник: %d/%d активных

Для изменения данных используйте админские функции или прямые SQL-запросы к базе данных.`,
                        userCount, activeVets, totalVets, activeClinics, totalClinics))
        msg.ParseMode = "Markdown"
        h.bot.Send(msg)
}</span>

// HandleStats показывает статистику бота
func (h *AdminHandlers) HandleStats(update tgbotapi.Update) <span class="cov0" title="0">{
        userCount, _ := h.getUserCount()
        activeVets, _ := h.getActiveVetCount()
        totalVets, _ := h.getTotalVetCount()
        activeClinics, _ := h.getActiveClinicCount()
        totalClinics, _ := h.getTotalClinicCount()
        requestCount, _ := h.getRequestCount()

        statsMsg := fmt.Sprintf(`📊 *Статистика бота*

👥 Пользователей: %d
👨‍⚕️ Врачей: %d/%d активных
🏥 Клиник: %d/%d активных
📞 Запросов: %d

Система работает стабильно ✅`, userCount, activeVets, totalVets, activeClinics, totalClinics, requestCount)

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, statsMsg)
        msg.ParseMode = "Markdown"
        h.bot.Send(msg)
}</span>

// closeAdmin закрывает админскую панель
func (h *AdminHandlers) closeAdmin(update tgbotapi.Update) <span class="cov0" title="0">{
        userID := update.Message.From.ID

        // Очищаем все временные данные пользователя
        h.cleanTempData(userID)
        delete(h.adminState, userID)

        removeKeyboard := tgbotapi.NewRemoveKeyboard(true)
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Админская панель закрыта")
        msg.ReplyMarkup = removeKeyboard
        h.bot.Send(msg)
}</span>

// ========== ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ДЛЯ РАБОТЫ С БАЗОЙ ДАННЫХ ==========

// isValidSpecializationIDs проверяет валидность введенных ID специализаций
func (h *AdminHandlers) isValidSpecializationIDs(input string) bool <span class="cov0" title="0">{
        if input == "" </span><span class="cov0" title="0">{
                return true // Пустая строка допустима (очистка специализаций)
        }</span>

        // Получаем максимальный ID специализации для проверки
        <span class="cov0" title="0">maxID, err := h.getMaxSpecializationID()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting max specialization ID: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">ids := strings.Split(input, ",")
        for _, idStr := range ids </span><span class="cov0" title="0">{
                id, err := strconv.Atoi(strings.TrimSpace(idStr))
                if err != nil || id &lt;= 0 || id &gt; maxID </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Дополнительная проверка существования специализации в БД
                <span class="cov0" title="0">exists, err := h.db.SpecializationExists(id)
                if err != nil || !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// getMaxSpecializationID возвращает максимальный ID специализации
func (h *AdminHandlers) getMaxSpecializationID() (int, error) <span class="cov0" title="0">{
        var maxID int
        err := h.db.GetDB().QueryRow("SELECT COALESCE(MAX(id), 0) FROM specializations").Scan(&amp;maxID)
        return maxID, err
}</span>

// addVeterinarian добавляет врача в базу данных
func (h *AdminHandlers) addVeterinarian(vet *models.Veterinarian, specsText string) error <span class="cov0" title="0">{
        // Добавляем врача в базу
        query := `INSERT INTO veterinarians (first_name, last_name, phone, is_active) 
                  VALUES ($1, $2, $3, $4) RETURNING id`

        err := h.db.GetDB().QueryRow(query, vet.FirstName, vet.LastName, vet.Phone, vet.IsActive).
                Scan(&amp;vet.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Обрабатываем специализации
        <span class="cov0" title="0">if specsText != "" </span><span class="cov0" title="0">{
                specIDs := strings.Split(specsText, ",")
                log.Printf("Adding vet ID %d with specializations: %v", vet.ID, specIDs)

                for _, specIDStr := range specIDs </span><span class="cov0" title="0">{
                        specID, err := strconv.Atoi(strings.TrimSpace(specIDStr))
                        if err == nil &amp;&amp; specID &gt; 0 </span><span class="cov0" title="0">{
                                // Проверяем существование специализации
                                exists, err := h.db.SpecializationExists(specID)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error checking specialization %d: %v", specID, err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                        // Добавляем связь врач-специализация
                                        _, err = h.db.GetDB().Exec(
                                                "INSERT INTO vet_specializations (vet_id, specialization_id) VALUES ($1, $2)",
                                                vet.ID, specID,
                                        )
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error adding specialization %d: %v", specID, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Printf("Successfully added specialization %d for vet %d", specID, vet.ID)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        log.Printf("Specialization %d does not exist", specID)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// updateVeterinarianField обновляет поле врача в базе данных
func (h *AdminHandlers) updateVeterinarianField(vetID int, field string, value string) error <span class="cov0" title="0">{
        var query string
        var err error

        switch field </span>{
        case "first_name":<span class="cov0" title="0">
                query = "UPDATE veterinarians SET first_name = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, value, vetID)</span>
        case "phone":<span class="cov0" title="0">
                query = "UPDATE veterinarians SET phone = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, value, vetID)</span>
        case "email":<span class="cov0" title="0">
                if value == "" </span><span class="cov0" title="0">{
                        query = "UPDATE veterinarians SET email = NULL WHERE id = $1"
                        _, err = h.db.GetDB().Exec(query, vetID)
                }</span> else<span class="cov0" title="0"> {
                        query = "UPDATE veterinarians SET email = $1 WHERE id = $2"
                        _, err = h.db.GetDB().Exec(query, value, vetID)
                }</span>
        case "experience_years":<span class="cov0" title="0">
                if value == "" </span><span class="cov0" title="0">{
                        query = "UPDATE veterinarians SET experience_years = NULL WHERE id = $1"
                        _, err = h.db.GetDB().Exec(query, vetID)
                }</span> else<span class="cov0" title="0"> {
                        exp, convErr := strconv.ParseInt(value, 10, 64)
                        if convErr != nil </span><span class="cov0" title="0">{
                                return convErr
                        }</span>
                        <span class="cov0" title="0">query = "UPDATE veterinarians SET experience_years = $1 WHERE id = $2"
                        _, err = h.db.GetDB().Exec(query, exp, vetID)</span>
                }
        case "is_active":<span class="cov0" title="0">
                active, convErr := strconv.ParseBool(value)
                if convErr != nil </span><span class="cov0" title="0">{
                        return convErr
                }</span>
                <span class="cov0" title="0">query = "UPDATE veterinarians SET is_active = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, active, vetID)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown field: %s", field)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// updateVeterinarianSpecializations обновляет специализации врача
func (h *AdminHandlers) updateVeterinarianSpecializations(vetID int, specsText string) error <span class="cov0" title="0">{
        // Удаляем все текущие специализации врача
        _, err := h.db.GetDB().Exec("DELETE FROM vet_specializations WHERE vet_id = $1", vetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Добавляем новые специализации, если они указаны
        <span class="cov0" title="0">if specsText != "" </span><span class="cov0" title="0">{
                specIDs := strings.Split(specsText, ",")
                for _, specIDStr := range specIDs </span><span class="cov0" title="0">{
                        specID, err := strconv.Atoi(strings.TrimSpace(specIDStr))
                        if err == nil &amp;&amp; specID &gt; 0 </span><span class="cov0" title="0">{
                                // Проверяем существование специализации
                                exists, err := h.db.SpecializationExists(specID)
                                if err == nil &amp;&amp; exists </span><span class="cov0" title="0">{
                                        _, err = h.db.GetDB().Exec(
                                                "INSERT INTO vet_specializations (vet_id, specialization_id) VALUES ($1, $2)",
                                                vetID, specID,
                                        )
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error adding specialization %d: %v", specID, err)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// deleteVeterinarian удаляет врача из базы данных
func (h *AdminHandlers) deleteVeterinarian(vetID int) error <span class="cov0" title="0">{
        // Удаляем связи с специализациями
        _, err := h.db.GetDB().Exec("DELETE FROM vet_specializations WHERE vet_id = $1", vetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Удаляем расписание врача
        <span class="cov0" title="0">_, err = h.db.GetDB().Exec("DELETE FROM schedules WHERE vet_id = $1", vetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Удаляем врача
        <span class="cov0" title="0">_, err = h.db.GetDB().Exec("DELETE FROM veterinarians WHERE id = $1", vetID)
        return err</span>
}

// updateClinicField обновляет поле клиники в базе данных
func (h *AdminHandlers) updateClinicField(clinicID int, field string, value string) error <span class="cov0" title="0">{
        var query string
        var err error

        switch field </span>{
        case "name":<span class="cov0" title="0">
                query = "UPDATE clinics SET name = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, value, clinicID)</span>
        case "address":<span class="cov0" title="0">
                query = "UPDATE clinics SET address = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, value, clinicID)</span>
        case "phone":<span class="cov0" title="0">
                if value == "" </span><span class="cov0" title="0">{
                        query = "UPDATE clinics SET phone = NULL WHERE id = $1"
                        _, err = h.db.GetDB().Exec(query, clinicID)
                }</span> else<span class="cov0" title="0"> {
                        query = "UPDATE clinics SET phone = $1 WHERE id = $2"
                        _, err = h.db.GetDB().Exec(query, value, clinicID)
                }</span>
        case "working_hours":<span class="cov0" title="0">
                if value == "" </span><span class="cov0" title="0">{
                        query = "UPDATE clinics SET working_hours = NULL WHERE id = $1"
                        _, err = h.db.GetDB().Exec(query, clinicID)
                }</span> else<span class="cov0" title="0"> {
                        query = "UPDATE clinics SET working_hours = $1 WHERE id = $2"
                        _, err = h.db.GetDB().Exec(query, value, clinicID)
                }</span>
        case "is_active":<span class="cov0" title="0">
                active, convErr := strconv.ParseBool(value)
                if convErr != nil </span><span class="cov0" title="0">{
                        return convErr
                }</span>
                <span class="cov0" title="0">query = "UPDATE clinics SET is_active = $1 WHERE id = $2"
                _, err = h.db.GetDB().Exec(query, active, clinicID)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown field: %s", field)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// deleteClinic удаляет клинику из базы данных
func (h *AdminHandlers) deleteClinic(clinicID int) error <span class="cov0" title="0">{
        // Удаляем расписание, связанное с клиникой
        _, err := h.db.GetDB().Exec("DELETE FROM schedules WHERE clinic_id = $1", clinicID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Удаляем клинику
        <span class="cov0" title="0">_, err = h.db.GetDB().Exec("DELETE FROM clinics WHERE id = $1", clinicID)
        return err</span>
}

// getStringTempData получает строковые данные из временного хранилища
func (h *AdminHandlers) getStringTempData(key string) string <span class="cov0" title="0">{
        if value, exists := h.tempData[key]; exists </span><span class="cov0" title="0">{
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// ========== МЕТОДЫ ДЛЯ СТАТИСТИКИ ==========

func (h *AdminHandlers) getUserCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM users"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (h *AdminHandlers) getActiveVetCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM veterinarians WHERE is_active = true"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (h *AdminHandlers) getTotalVetCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM veterinarians"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (h *AdminHandlers) getActiveClinicCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM clinics WHERE is_active = true"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (h *AdminHandlers) getTotalClinicCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM clinics"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (h *AdminHandlers) getRequestCount() (int, error) <span class="cov0" title="0">{
        query := "SELECT COUNT(*) FROM user_requests"
        var count int
        err := h.db.GetDB().QueryRow(query).Scan(&amp;count)
        return count, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "log"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// BotHandlers содержит базовые обработчики бота
type BotHandlers struct {
        bot *tgbotapi.BotAPI
}

// NewBotHandlers создает новый экземпляр BotHandlers
func NewBotHandlers(bot *tgbotapi.BotAPI) *BotHandlers <span class="cov8" title="1">{
        return &amp;BotHandlers{
                bot: bot,
        }
}</span>

// HandleUnknownCommand обрабатывает неизвестные команды
func (h *BotHandlers) HandleUnknownCommand(update tgbotapi.Update) <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                "❌ Неизвестная команда.\n\n"+
                        "Используйте /help для просмотра доступных команд.")
        h.bot.Send(msg)
}</span>

// HandleErrorMessage обрабатывает ошибки
func (h *BotHandlers) HandleErrorMessage(chatID int64, errorMsg string) <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID,
                "⚠️ Произошла ошибка. Пожалуйста, попробуйте позже.")
        h.bot.Send(msg)

        // Логируем ошибку для администратора
        log.Printf("Error for user %d: %s", chatID, errorMsg)
}</span>

// SendWelcomeMessage отправляет приветственное сообщение
func (h *BotHandlers) SendWelcomeMessage(chatID int64) <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID,
                `🐾 Добро пожаловать в VetBot! 🐾

Я ваш помощник в поиске ветеринарных врачей. Я могу:

• Показать врачей по специализации
• Найти врачей на конкретный день
• Показать контакты клиник
• Предоставить расписание приема

Начните с команды /help чтобы увидеть все возможности!`)
        h.bot.Send(msg)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "log"
        "strconv"
        "strings"

        "github.com/drerr0r/vetbot/pkg/utils"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// MainHandler обрабатывает все входящие обновления
type MainHandler struct {
        bot           BotAPI   // Используем интерфейс
        db            Database // Используем интерфейс
        config        *utils.Config
        vetHandlers   *VetHandlers
        adminHandlers *AdminHandlers
}

// NewMainHandler создает новый экземпляр MainHandler
func NewMainHandler(bot BotAPI, db Database, config *utils.Config) *MainHandler <span class="cov8" title="1">{
        return &amp;MainHandler{
                bot:           bot,
                db:            db,
                config:        config,
                vetHandlers:   NewVetHandlers(bot, db),
                adminHandlers: NewAdminHandlers(bot, db, config), // Исправлено количество аргументов
        }
}</span>

// HandleUpdate обрабатывает входящее обновление от Telegram
func (h *MainHandler) HandleUpdate(update tgbotapi.Update) <span class="cov0" title="0">{
        log.Printf("Received update")

        // Обрабатываем callback queries (нажатия на inline кнопки)
        if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                log.Printf("Callback query: %s", update.CallbackQuery.Data)
                h.vetHandlers.HandleCallback(update)
                return
        }</span>

        // Игнорируем любые не-text сообщения
        <span class="cov0" title="0">if update.Message == nil </span><span class="cov0" title="0">{
                log.Printf("Message is nil")
                return
        }</span>

        <span class="cov0" title="0">if update.Message.Text == "" </span><span class="cov0" title="0">{
                log.Printf("Text is empty")
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Processing message: %s", update.Message.Text)

        // Проверяем, является ли пользователь администратором
        isAdmin := h.isAdmin(update.Message.From.ID)
        log.Printf("User %d is admin: %t", update.Message.From.ID, isAdmin)

        // Если пользователь администратор и находится в админском режиме, передаем админским хендлерам
        if isAdmin &amp;&amp; h.isInAdminMode(update.Message.From.ID) </span><span class="cov0" title="0">{
                log.Printf("Redirecting to admin handlers")
                h.adminHandlers.HandleAdminMessage(update)
                return
        }</span>

        // Сначала проверяем команды поиска (/search_1, /search_2 и т.д.)
        <span class="cov0" title="0">if strings.HasPrefix(update.Message.Text, "/search_") </span><span class="cov0" title="0">{
                log.Printf("Is search command: %s", update.Message.Text)
                h.handleSearchCommand(update)
                return
        }</span>

        // Затем проверяем обычные команды
        <span class="cov0" title="0">if update.Message.IsCommand() </span><span class="cov0" title="0">{
                log.Printf("Is command: %s", update.Message.Command())
                h.handleCommand(update, isAdmin)
                return
        }</span>

        // Обычные текстовые сообщения
        <span class="cov0" title="0">log.Printf("Is text message: %s", update.Message.Text)
        h.handleTextMessage(update)</span>
}

// handleCommand обрабатывает текстовые команды
func (h *MainHandler) handleCommand(update tgbotapi.Update, isAdmin bool) <span class="cov0" title="0">{
        command := update.Message.Command()
        log.Printf("Handling command: %s", command)

        switch command </span>{
        case "start":<span class="cov0" title="0">
                log.Printf("Executing /start")
                h.vetHandlers.HandleStart(update)</span>
        case "specializations":<span class="cov0" title="0">
                log.Printf("Executing /specializations")
                h.vetHandlers.HandleSpecializations(update)</span>
        case "search":<span class="cov0" title="0">
                log.Printf("Executing /search")
                h.vetHandlers.HandleSearch(update)</span>
        case "clinics":<span class="cov0" title="0">
                log.Printf("Executing /clinics")
                h.vetHandlers.HandleClinics(update)</span>
        case "help":<span class="cov0" title="0">
                log.Printf("Executing /help")
                h.vetHandlers.HandleHelp(update)</span>
        case "test":<span class="cov0" title="0">
                log.Printf("Executing /test")
                h.vetHandlers.HandleTest(update)</span>
        case "admin":<span class="cov0" title="0">
                if isAdmin </span><span class="cov0" title="0">{
                        log.Printf("Executing /admin")
                        h.adminHandlers.HandleAdmin(update)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Admin access denied for user %d", update.Message.From.ID)
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "У вас нет прав администратора")
                        h.bot.Send(msg)
                }</span>
        case "stats":<span class="cov0" title="0">
                if isAdmin </span><span class="cov0" title="0">{
                        log.Printf("Executing /stats")
                        h.adminHandlers.HandleStats(update)
                }</span>
        default:<span class="cov0" title="0">
                log.Printf("Unknown command: %s", command)
                msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                        "Неизвестная команда. Используйте /help для списка команд")
                h.bot.Send(msg)</span>
        }
}

// handleSearchCommand обрабатывает команды поиска по специализации (/search_1, /search_2 и т.д.)
func (h *MainHandler) handleSearchCommand(update tgbotapi.Update) <span class="cov0" title="0">{
        text := update.Message.Text
        log.Printf("Handling search command: %s", text)

        if strings.HasPrefix(text, "/search_") </span><span class="cov0" title="0">{
                specIDStr := strings.TrimPrefix(text, "/search_")
                specID, err := strconv.Atoi(specIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error parsing specialization ID: %v", err)
                        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Неверный формат команды поиска")
                        h.bot.Send(msg)
                        return
                }</span>
                <span class="cov0" title="0">log.Printf("Searching for specialization ID: %d", specID)
                h.vetHandlers.HandleSearchBySpecialization(update, specID)</span>
        }
}

// handleTextMessage обрабатывает обычные текстовые сообщения
func (h *MainHandler) handleTextMessage(update tgbotapi.Update) <span class="cov0" title="0">{
        // Для обычных пользователей показываем справку
        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                "Я понимаю только команды. Используйте /help для списка доступных команд.")
        h.bot.Send(msg)
}</span>

// isAdmin проверяет, является ли пользователь администратором
func (h *MainHandler) isAdmin(userID int64) bool <span class="cov8" title="1">{
        if h.config == nil || len(h.config.AdminIDs) == 0 </span><span class="cov8" title="1">{
                log.Printf("Config or AdminIDs is empty")
                return false
        }</span>

        <span class="cov8" title="1">for _, adminID := range h.config.AdminIDs </span><span class="cov8" title="1">{
                if userID == adminID </span><span class="cov8" title="1">{
                        log.Printf("User %d found in admin list", userID)
                        return true
                }</span>
        }

        <span class="cov8" title="1">log.Printf("User %d not found in admin list: %v", userID, h.config.AdminIDs)
        return false</span>
}

// isInAdminMode проверяет, находится ли пользователь в админском режиме
func (h *MainHandler) isInAdminMode(userID int64) bool <span class="cov8" title="1">{
        // Защита от nil указателя
        if h.adminHandlers == nil </span><span class="cov8" title="1">{
                log.Printf("Admin handlers is nil for user %d", userID)
                return false
        }</span>

        // Проверяем состояние админской сессии
        <span class="cov8" title="1">if state, exists := h.adminHandlers.adminState[userID]; exists </span><span class="cov8" title="1">{
                return state != ""
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "database/sql"
        "fmt"

        "github.com/drerr0r/vetbot/internal/models"
        "github.com/drerr0r/vetbot/pkg/utils"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// ============================================================================
// MOCK DATABASE
// ============================================================================

// MockDatabase представляет мок для базы данных
type MockDatabase struct {
        Users                map[int64]*models.User
        Specializations      map[int]*models.Specialization
        Veterinarians        map[int]*models.Veterinarian
        Clinics              map[int]*models.Clinic
        Schedules            map[int]*models.Schedule
        UserError            error
        SpecializationsError error
        VeterinariansError   error
        ClinicsError         error
        SchedulesError       error
}

// NewMockDatabase создает новый мок базы данных
func NewMockDatabase() *MockDatabase <span class="cov8" title="1">{
        return &amp;MockDatabase{
                Users:           make(map[int64]*models.User),
                Specializations: make(map[int]*models.Specialization),
                Veterinarians:   make(map[int]*models.Veterinarian),
                Clinics:         make(map[int]*models.Clinic),
                Schedules:       make(map[int]*models.Schedule),
        }
}</span>

// GetDB возвращает объект базы данных (для совместимости)
func (m *MockDatabase) GetDB() *sql.DB <span class="cov0" title="0">{
        return nil // Возвращаем nil для тестов
}</span>

// Close закрывает подключение (для совместимости)
func (m *MockDatabase) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// CreateUser создает пользователя
func (m *MockDatabase) CreateUser(user *models.User) error <span class="cov8" title="1">{
        if m.UserError != nil </span><span class="cov8" title="1">{
                return m.UserError
        }</span>
        <span class="cov8" title="1">m.Users[user.TelegramID] = user
        return nil</span>
}

// GetAllSpecializations возвращает все специализации
func (m *MockDatabase) GetAllSpecializations() ([]*models.Specialization, error) <span class="cov8" title="1">{
        if m.SpecializationsError != nil </span><span class="cov8" title="1">{
                return nil, m.SpecializationsError
        }</span>

        <span class="cov8" title="1">result := make([]*models.Specialization, 0, len(m.Specializations))
        for _, spec := range m.Specializations </span><span class="cov8" title="1">{
                result = append(result, spec)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetSpecializationByID возвращает специализацию по ID
func (m *MockDatabase) GetSpecializationByID(id int) (*models.Specialization, error) <span class="cov8" title="1">{
        if m.SpecializationsError != nil </span><span class="cov0" title="0">{
                return nil, m.SpecializationsError
        }</span>

        <span class="cov8" title="1">spec, exists := m.Specializations[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, sql.ErrNoRows
        }</span>
        <span class="cov8" title="1">return spec, nil</span>
}

// SpecializationExists проверяет существование специализации
func (m *MockDatabase) SpecializationExists(id int) (bool, error) <span class="cov0" title="0">{
        _, exists := m.Specializations[id]
        return exists, nil
}</span>

// GetVeterinariansBySpecialization возвращает врачей по специализации
func (m *MockDatabase) GetVeterinariansBySpecialization(specializationID int) ([]*models.Veterinarian, error) <span class="cov8" title="1">{
        if m.VeterinariansError != nil </span><span class="cov8" title="1">{
                return nil, m.VeterinariansError
        }</span>

        <span class="cov8" title="1">result := make([]*models.Veterinarian, 0)
        for _, vet := range m.Veterinarians </span><span class="cov8" title="1">{
                for _, spec := range vet.Specializations </span><span class="cov8" title="1">{
                        if spec.ID == specializationID </span><span class="cov8" title="1">{
                                result = append(result, vet)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetAllClinics возвращает все клиники
func (m *MockDatabase) GetAllClinics() ([]*models.Clinic, error) <span class="cov8" title="1">{
        if m.ClinicsError != nil </span><span class="cov8" title="1">{
                return nil, m.ClinicsError
        }</span>

        <span class="cov8" title="1">result := make([]*models.Clinic, 0, len(m.Clinics))
        for _, clinic := range m.Clinics </span><span class="cov8" title="1">{
                result = append(result, clinic)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetSchedulesByVetID возвращает расписание врача
func (m *MockDatabase) GetSchedulesByVetID(vetID int) ([]*models.Schedule, error) <span class="cov8" title="1">{
        if m.SchedulesError != nil </span><span class="cov0" title="0">{
                return nil, m.SchedulesError
        }</span>

        <span class="cov8" title="1">result := make([]*models.Schedule, 0)
        for _, schedule := range m.Schedules </span><span class="cov8" title="1">{
                if schedule.VetID == vetID </span><span class="cov8" title="1">{
                        result = append(result, schedule)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetSpecializationsByVetID возвращает специализации врача
func (m *MockDatabase) GetSpecializationsByVetID(vetID int) ([]*models.Specialization, error) <span class="cov8" title="1">{
        vet, exists := m.Veterinarians[vetID]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>
        <span class="cov8" title="1">return vet.Specializations, nil</span>
}

// FindAvailableVets ищет доступных врачей
func (m *MockDatabase) FindAvailableVets(criteria *models.SearchCriteria) ([]*models.Veterinarian, error) <span class="cov8" title="1">{
        if m.VeterinariansError != nil </span><span class="cov0" title="0">{
                return nil, m.VeterinariansError
        }</span>

        <span class="cov8" title="1">result := make([]*models.Veterinarian, 0)

        for _, vet := range m.Veterinarians </span><span class="cov8" title="1">{
                // Фильтрация по специализации
                if criteria.SpecializationID &gt; 0 </span><span class="cov0" title="0">{
                        found := false
                        for _, spec := range vet.Specializations </span><span class="cov0" title="0">{
                                if spec.ID == criteria.SpecializationID </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Фильтрация по дню недели
                <span class="cov8" title="1">if criteria.DayOfWeek &gt; 0 </span><span class="cov8" title="1">{
                        hasSchedule := false
                        for _, schedule := range m.Schedules </span><span class="cov8" title="1">{
                                if schedule.VetID == vet.ID &amp;&amp; schedule.DayOfWeek == criteria.DayOfWeek </span><span class="cov8" title="1">{
                                        hasSchedule = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !hasSchedule </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                // Фильтрация по клинике
                <span class="cov8" title="1">if criteria.ClinicID &gt; 0 </span><span class="cov8" title="1">{
                        hasClinic := false
                        for _, schedule := range m.Schedules </span><span class="cov8" title="1">{
                                if schedule.VetID == vet.ID &amp;&amp; schedule.ClinicID == criteria.ClinicID </span><span class="cov8" title="1">{
                                        hasClinic = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !hasClinic </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">result = append(result, vet)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetAllVeterinarians возвращает всех врачей
func (m *MockDatabase) GetAllVeterinarians() ([]*models.Veterinarian, error) <span class="cov0" title="0">{
        result := make([]*models.Veterinarian, 0, len(m.Veterinarians))
        for _, vet := range m.Veterinarians </span><span class="cov0" title="0">{
                result = append(result, vet)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// GetVeterinarianByID возвращает врача по ID
func (m *MockDatabase) GetVeterinarianByID(id int) (*models.Veterinarian, error) <span class="cov0" title="0">{
        vet, exists := m.Veterinarians[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return vet, nil</span>
}

// GetClinicByID возвращает клинику по ID
func (m *MockDatabase) GetClinicByID(id int) (*models.Clinic, error) <span class="cov0" title="0">{
        clinic, exists := m.Clinics[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, sql.ErrNoRows
        }</span>
        <span class="cov0" title="0">return clinic, nil</span>
}

// AddMissingColumns добавляет отсутствующие колонки
func (m *MockDatabase) AddMissingColumns() error <span class="cov0" title="0">{
        return nil
}</span>

// AddTestVeterinarian добавляет тестового ветеринара
func (m *MockDatabase) AddTestVeterinarian(id int, firstName, lastName, phone string) <span class="cov0" title="0">{
        m.Veterinarians[id] = &amp;models.Veterinarian{
                ID:              id,
                FirstName:       firstName,
                LastName:        lastName,
                Phone:           phone,
                Specializations: []*models.Specialization{},
        }
}</span>

// AddTestSpecialization добавляет тестовую специализацию
func (m *MockDatabase) AddTestSpecialization(id int, name string) <span class="cov0" title="0">{
        m.Specializations[id] = &amp;models.Specialization{
                ID:   id,
                Name: name,
        }
}</span>

// ============================================================================
// MOCK BOT
// ============================================================================

// MockBot представляет мок для Telegram бота
type MockBot struct {
        SentMessages   []tgbotapi.MessageConfig
        Callbacks      []tgbotapi.CallbackConfig
        EditedMessages []tgbotapi.EditMessageTextConfig
}

// NewMockBot создает новый мок бота
func NewMockBot() *MockBot <span class="cov8" title="1">{
        return &amp;MockBot{
                SentMessages:   make([]tgbotapi.MessageConfig, 0),
                Callbacks:      make([]tgbotapi.CallbackConfig, 0),
                EditedMessages: make([]tgbotapi.EditMessageTextConfig, 0),
        }
}</span>

// Send имитирует отправку сообщения
func (m *MockBot) Send(c tgbotapi.Chattable) (tgbotapi.Message, error) <span class="cov8" title="1">{
        switch msg := c.(type) </span>{
        case tgbotapi.MessageConfig:<span class="cov8" title="1">
                m.SentMessages = append(m.SentMessages, msg)
                return tgbotapi.Message{MessageID: len(m.SentMessages)}, nil</span>
        case tgbotapi.CallbackConfig:<span class="cov8" title="1">
                m.Callbacks = append(m.Callbacks, msg)
                return tgbotapi.Message{}, nil</span>
        case tgbotapi.EditMessageTextConfig:<span class="cov8" title="1">
                m.EditedMessages = append(m.EditedMessages, msg)
                return tgbotapi.Message{MessageID: len(m.EditedMessages)}, nil</span>
        default:<span class="cov0" title="0">
                return tgbotapi.Message{}, fmt.Errorf("unsupported message type: %T", c)</span>
        }
}

// Request имитирует запрос к API
func (m *MockBot) Request(c tgbotapi.Chattable) (*tgbotapi.APIResponse, error) <span class="cov8" title="1">{
        return &amp;tgbotapi.APIResponse{Ok: true}, nil
}</span>

// GetSentMessages возвращает отправленные сообщения
func (m *MockBot) GetSentMessages() []tgbotapi.MessageConfig <span class="cov0" title="0">{
        return m.SentMessages
}</span>

// GetLastMessage возвращает последнее отправленное сообщение
func (m *MockBot) GetLastMessage() *tgbotapi.MessageConfig <span class="cov8" title="1">{
        if len(m.SentMessages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;m.SentMessages[len(m.SentMessages)-1]</span>
}

// GetLastEditedMessage возвращает последнее отредактированное сообщение
func (m *MockBot) GetLastEditedMessage() *tgbotapi.EditMessageTextConfig <span class="cov8" title="1">{
        if len(m.EditedMessages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;m.EditedMessages[len(m.EditedMessages)-1]</span>
}

// Clear очищает историю сообщений
func (m *MockBot) Clear() <span class="cov0" title="0">{
        m.SentMessages = make([]tgbotapi.MessageConfig, 0)
        m.Callbacks = make([]tgbotapi.CallbackConfig, 0)
        m.EditedMessages = make([]tgbotapi.EditMessageTextConfig, 0)
}</span>

// ============================================================================
// TEST UTILITIES
// ============================================================================

// TestUpdateBuilder помогает создавать тестовые обновления
type TestUpdateBuilder struct {
        update tgbotapi.Update
}

// NewTestUpdate создает новый билдер обновлений
func NewTestUpdate() *TestUpdateBuilder <span class="cov8" title="1">{
        return &amp;TestUpdateBuilder{
                update: tgbotapi.Update{},
        }
}</span>

// WithMessage добавляет сообщение
func (b *TestUpdateBuilder) WithMessage(text string, chatID int64, userID int64) *TestUpdateBuilder <span class="cov8" title="1">{
        b.update.Message = &amp;tgbotapi.Message{
                Text: text,
                Chat: &amp;tgbotapi.Chat{ID: chatID},
                From: &amp;tgbotapi.User{ID: userID},
        }
        return b
}</span>

// WithCallback добавляет callback query
func (b *TestUpdateBuilder) WithCallback(data string, chatID int64, messageID int) *TestUpdateBuilder <span class="cov8" title="1">{
        b.update.CallbackQuery = &amp;tgbotapi.CallbackQuery{
                ID:      "test_callback",
                Data:    data,
                Message: &amp;tgbotapi.Message{Chat: &amp;tgbotapi.Chat{ID: chatID}, MessageID: messageID},
        }
        return b
}</span>

// Build возвращает собранное обновление
func (b *TestUpdateBuilder) Build() tgbotapi.Update <span class="cov8" title="1">{
        return b.update
}</span>

// CreateTestConfig создает тестовую конфигурацию
func CreateTestConfig() *utils.Config <span class="cov8" title="1">{
        return &amp;utils.Config{
                TelegramToken: "test_token",
                DatabaseURL:   "test_url",
                Debug:         true,
                AdminIDs:      []int64{12345},
        }
}</span>

// CreateTestMainHandlers создает тестовые MainHandler
func CreateTestMainHandlers() (*MainHandler, *MockBot) <span class="cov0" title="0">{
        mockBot := NewMockBot()

        // Создаем nil базу данных для тестов
        var db Database = nil
        config := CreateTestConfig()

        mainHandler := NewMainHandler(mockBot, db, config)
        return mainHandler, mockBot
}</span>

// CreateTestVetHandlers создает тестовые VetHandlers
func CreateTestVetHandlers() (*VetHandlers, *MockBot, *MockDatabase) <span class="cov0" title="0">{
        mockBot := NewMockBot()
        mockDB := NewMockDatabase()
        handlers := NewVetHandlers(mockBot, mockDB)
        return handlers, mockBot, mockDB
}</span>

// CreateTestAdminHandlers создает тестовые AdminHandlers
func CreateTestAdminHandlers() (*AdminHandlers, *MockBot, *MockDatabase) <span class="cov0" title="0">{
        mockBot := NewMockBot()
        mockDB := NewMockDatabase()
        config := CreateTestConfig()
        handlers := NewAdminHandlers(mockBot, mockDB, config)
        return handlers, mockBot, mockDB
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "fmt"
        "html"
        "log"
        "strconv"
        "strings"

        "github.com/drerr0r/vetbot/internal/models"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// VetHandlers содержит обработчики для ветеринарного бота
type VetHandlers struct {
        bot BotAPI
        db  Database
}

// NewVetHandlers создает новый экземпляр VetHandlers
func NewVetHandlers(bot BotAPI, db Database) *VetHandlers <span class="cov8" title="1">{
        return &amp;VetHandlers{
                bot: bot,
                db:  db,
        }
}</span>

// HandleStart обрабатывает команду /start
func (h *VetHandlers) HandleStart(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleStart called")

        // Создаем или обновляем пользователя
        user := &amp;models.User{
                TelegramID: update.Message.From.ID,
                Username:   update.Message.From.UserName,
                FirstName:  update.Message.From.FirstName,
                LastName:   update.Message.From.LastName,
        }

        err := h.db.CreateUser(user)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error creating user: %v", err)
        }</span>

        // Создаем главное меню с inline-кнопками
        <span class="cov8" title="1">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔍 Поиск по специализациям", "main_specializations"),
                        tgbotapi.NewInlineKeyboardButtonData("🕐 Поиск по времени", "main_time"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🏥 Поиск по клиникам", "main_clinics"),
                        tgbotapi.NewInlineKeyboardButtonData("ℹ️ Помощь", "main_help"),
                ),
        )

        msg := tgbotapi.NewMessage(update.Message.Chat.ID,
                `🐾 Добро пожаловать в VetBot! 🐾

Я ваш помощник в поиске ветеринарных врачей. Выберите способ поиска:`)
        msg.ReplyMarkup = keyboard

        log.Printf("Sending start message with inline keyboard")
        _, err = h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending start message: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Start message sent successfully")
        }</span>
}

// HandleSpecializations показывает список специализаций с улучшенным интерфейсом
func (h *VetHandlers) HandleSpecializations(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleSpecializations called")

        var chatID int64

        // Определяем chatID в зависимости от типа update
        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                chatID = update.CallbackQuery.Message.Chat.ID
                // Отвечаем на callback query чтобы убрать "часики" у кнопки
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov8" title="1"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        <span class="cov8" title="1">specializations, err := h.db.GetAllSpecializations()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting specializations: %v", err)
                msg := tgbotapi.NewMessage(chatID, "Ошибка при получении списка специализаций")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Found %d specializations", len(specializations))

        if len(specializations) == 0 </span><span class="cov8" title="1">{
                msg := tgbotapi.NewMessage(chatID, "Специализации не найдены")
                h.bot.Send(msg)
                return
        }</span>

        // Создаем кнопки для специализаций (максимум 3 в ряду)
        <span class="cov8" title="1">var keyboardRows [][]tgbotapi.InlineKeyboardButton
        var currentRow []tgbotapi.InlineKeyboardButton

        for i, spec := range specializations </span><span class="cov8" title="1">{
                btn := tgbotapi.NewInlineKeyboardButtonData(
                        spec.Name,
                        fmt.Sprintf("search_spec_%d", spec.ID),
                )
                currentRow = append(currentRow, btn)

                // Создаем новый ряд после каждых 3 кнопок или в конце
                if (i+1)%3 == 0 || i == len(specializations)-1 </span><span class="cov8" title="1">{
                        keyboardRows = append(keyboardRows, currentRow)
                        currentRow = []tgbotapi.InlineKeyboardButton{}
                }</span>
        }

        // Добавляем кнопку "Назад"
        <span class="cov8" title="1">backRow := tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData("🔙 Назад", "main_menu"),
        )
        keyboardRows = append(keyboardRows, backRow)

        keyboard := tgbotapi.NewInlineKeyboardMarkup(keyboardRows...)

        msg := tgbotapi.NewMessage(chatID,
                "🏥 *Выберите специализацию врача:*\n\nНажмите на кнопку с нужной специализацией для поиска врачей.")
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        log.Printf("Sending specializations menu to chat %d", chatID)
        _, err = h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending specializations menu: %v", err)
        }</span>
}

// HandleSearch показывает меню поиска по времени
func (h *VetHandlers) HandleSearch(update tgbotapi.Update) <span class="cov0" title="0">{
        log.Printf("HandleSearch called")

        var chatID int64

        // Определяем chatID в зависимости от типа update
        if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                chatID = update.CallbackQuery.Message.Chat.ID
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov0" title="0"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        // Создаем клавиатуру с днями недели и кнопкой "Назад"
        <span class="cov0" title="0">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("Понедельник", "search_day_1"),
                        tgbotapi.NewInlineKeyboardButtonData("Вторник", "search_day_2"),
                        tgbotapi.NewInlineKeyboardButtonData("Среда", "search_day_3"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("Четверг", "search_day_4"),
                        tgbotapi.NewInlineKeyboardButtonData("Пятница", "search_day_5"),
                        tgbotapi.NewInlineKeyboardButtonData("Суббота", "search_day_6"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("Воскресенье", "search_day_7"),
                        tgbotapi.NewInlineKeyboardButtonData("Любой день", "search_day_0"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔙 Назад", "main_menu"),
                ),
        )

        msg := tgbotapi.NewMessage(chatID,
                "🕐 *Выберите день недели для поиска:*\n\nЯ покажу врачей, работающих в выбранный день.")
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        log.Printf("Sending search by time menu to chat %d", chatID)
        _, err := h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending search menu: %v", err)
        }</span>
}

// HandleClinics показывает меню клиник
func (h *VetHandlers) HandleClinics(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleClinics called")

        var chatID int64

        // Определяем chatID в зависимости от типа update
        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                chatID = update.CallbackQuery.Message.Chat.ID
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov0" title="0"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        <span class="cov8" title="1">clinics, err := h.db.GetAllClinics()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting clinics: %v", err)
                msg := tgbotapi.NewMessage(chatID, "Ошибка при получении списка клиник")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Found %d clinics", len(clinics))

        if len(clinics) == 0 </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(chatID, "Клиники не найдены")
                h.bot.Send(msg)
                return
        }</span>

        // Создаем кнопки для клиник
        <span class="cov8" title="1">var keyboardRows [][]tgbotapi.InlineKeyboardButton
        var currentRow []tgbotapi.InlineKeyboardButton

        for i, clinic := range clinics </span><span class="cov8" title="1">{
                btn := tgbotapi.NewInlineKeyboardButtonData(
                        clinic.Name,
                        fmt.Sprintf("search_clinic_%d", clinic.ID),
                )
                currentRow = append(currentRow, btn)

                // Создаем новый ряд после каждых 2 кнопок или в конце
                if (i+1)%2 == 0 || i == len(clinics)-1 </span><span class="cov8" title="1">{
                        keyboardRows = append(keyboardRows, currentRow)
                        currentRow = []tgbotapi.InlineKeyboardButton{}
                }</span>
        }

        // Добавляем кнопку "Назад"
        <span class="cov8" title="1">backRow := tgbotapi.NewInlineKeyboardRow(
                tgbotapi.NewInlineKeyboardButtonData("🔙 Назад", "main_menu"),
        )
        keyboardRows = append(keyboardRows, backRow)

        keyboard := tgbotapi.NewInlineKeyboardMarkup(keyboardRows...)

        msg := tgbotapi.NewMessage(chatID,
                "🏥 *Выберите клинику:*\n\nЯ покажу врачей, работающих в выбранной клинике.")
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        log.Printf("Sending clinics menu to chat %d", chatID)
        _, err = h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending clinics menu: %v", err)
        }</span>
}

// HandleHelp показывает справку с кнопкой "Назад"
func (h *VetHandlers) HandleHelp(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleHelp called")

        var chatID int64

        // Определяем chatID в зависимости от типа update
        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                chatID = update.CallbackQuery.Message.Chat.ID
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov0" title="0"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        <span class="cov8" title="1">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔙 Назад", "main_menu"),
                ),
        )

        helpText := `🐾 *VetBot - Помощь* 🐾

*Основные функции:*
• 🔍 *Поиск по специализациям* - найти врача по направлению
• 🕐 *Поиск по времени* - найти врача по дню недели
• 🏥 *Поиск по клиникам* - найти врачей в конкретной клинике

*Как пользоваться:*
1. Выберите способ поиска из главного меню
2. Нажмите на нужную кнопку (специализация, день или клиника)
3. Бот покажет список врачей с контактами и расписанием

*Команды:*
/start - Главное меню
/help - Эта справка`

        msg := tgbotapi.NewMessage(chatID, helpText)
        msg.ParseMode = "Markdown"
        msg.ReplyMarkup = keyboard

        log.Printf("Sending help message to chat %d", chatID)
        _, err := h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending help message: %v", err)
        }</span>
}

// HandleSearchBySpecialization ищет врачей по специализации с кнопкой "Назад"
func (h *VetHandlers) HandleSearchBySpecialization(update tgbotapi.Update, specializationID int) <span class="cov8" title="1">{
        log.Printf("HandleSearchBySpecialization called with ID: %d", specializationID)

        var chatID int64
        var messageID int

        // Определяем chatID в зависимости от типа update
        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                chatID = update.CallbackQuery.Message.Chat.ID
                messageID = update.CallbackQuery.Message.MessageID
                // Отвечаем на callback query чтобы убрать "часики" у кнопки
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov0" title="0"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        <span class="cov8" title="1">vets, err := h.db.GetVeterinariansBySpecialization(specializationID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting veterinarians: %v", err)
                msg := tgbotapi.NewMessage(chatID, "Ошибка при поиске врачей")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Found %d veterinarians for specialization ID: %d", len(vets), specializationID)

        spec, err := h.db.GetSpecializationByID(specializationID)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error getting specialization: %v", err)
        }</span>

        // Создаем клавиатуру с кнопкой "Назад"
        <span class="cov8" title="1">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔙 К специализациям", "main_specializations"),
                        tgbotapi.NewInlineKeyboardButtonData("🏠 Главное меню", "main_menu"),
                ),
        )

        if len(vets) == 0 </span><span class="cov8" title="1">{
                var specName string
                if spec != nil </span><span class="cov8" title="1">{
                        specName = spec.Name
                }</span> else<span class="cov0" title="0"> {
                        specName = "выбранной специализации"
                }</span>

                <span class="cov8" title="1">msg := tgbotapi.NewMessage(chatID,
                        fmt.Sprintf("👨‍⚕️ *Врачи по специализации \"%s\" не найдены*\n\nПопробуйте выбрать другую специализацию.", specName))
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
                return</span>
        }

        <span class="cov8" title="1">var sb strings.Builder
        if spec != nil </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("👨‍⚕️ *Врачи по специализации \"%s\":*\n\n", html.EscapeString(spec.Name)))
        }</span> else<span class="cov8" title="1"> {
                sb.WriteString("👨‍⚕️ *Найденные врачи:*\n\n")
        }</span>

        <span class="cov8" title="1">for i, vet := range vets </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("**%d. %s %s**\n", i+1, html.EscapeString(vet.FirstName), html.EscapeString(vet.LastName)))
                sb.WriteString(fmt.Sprintf("📞 *Телефон:* `%s`\n", html.EscapeString(vet.Phone)))

                if vet.Email.Valid &amp;&amp; vet.Email.String != "" </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("📧 *Email:* %s\n", html.EscapeString(vet.Email.String)))
                }</span>

                <span class="cov8" title="1">if vet.ExperienceYears.Valid </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("💼 *Опыт:* %d лет\n", vet.ExperienceYears.Int64))
                }</span>

                // Специализации врача
                <span class="cov8" title="1">if len(vet.Specializations) &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString("🎯 *Специализации:* ")
                        specNames := make([]string, len(vet.Specializations))
                        for j, spec := range vet.Specializations </span><span class="cov8" title="1">{
                                specNames[j] = html.EscapeString(spec.Name)
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(strings.Join(specNames, ", "))
                        sb.WriteString("\n")</span>
                }

                // Расписание врача
                <span class="cov8" title="1">schedules, err := h.db.GetSchedulesByVetID(vet.ID)
                if err == nil &amp;&amp; len(schedules) &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString("🕐 *Расписание:*\n")
                        for _, schedule := range schedules </span><span class="cov8" title="1">{
                                dayName := getDayName(schedule.DayOfWeek)
                                startTime := schedule.StartTime
                                endTime := schedule.EndTime
                                if startTime != "" &amp;&amp; endTime != "" &amp;&amp; startTime != "00:00" &amp;&amp; endTime != "00:00" </span><span class="cov8" title="1">{
                                        sb.WriteString(fmt.Sprintf("   - %s: %s-%s", dayName, startTime, endTime))
                                        if schedule.Clinic != nil &amp;&amp; schedule.Clinic.Name != "" </span><span class="cov8" title="1">{
                                                sb.WriteString(fmt.Sprintf(" (%s)", html.EscapeString(schedule.Clinic.Name)))
                                        }</span>
                                        <span class="cov8" title="1">sb.WriteString("\n")</span>
                                }
                        }
                }

                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        // Если это callback query и есть messageID, редактируем существующее сообщение
        <span class="cov8" title="1">if update.CallbackQuery != nil &amp;&amp; messageID != 0 </span><span class="cov8" title="1">{
                editMsg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
                editMsg.ParseMode = "Markdown"
                editMsg.ReplyMarkup = &amp;keyboard
                _, err = h.bot.Send(editMsg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error editing message: %v", err)
                        // Если редактирование не удалось, отправляем новое сообщение
                        msg := tgbotapi.NewMessage(chatID, sb.String())
                        msg.ParseMode = "Markdown"
                        msg.ReplyMarkup = keyboard
                        h.bot.Send(msg)
                }</span>
        } else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(chatID, sb.String())
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
        }</span>
}

// HandleSearchByClinic ищет врачей по клинике
func (h *VetHandlers) HandleSearchByClinic(update tgbotapi.Update, clinicID int) <span class="cov8" title="1">{
        log.Printf("HandleSearchByClinic called with ID: %d", clinicID)

        var chatID int64
        var messageID int

        if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                chatID = update.CallbackQuery.Message.Chat.ID
                messageID = update.CallbackQuery.Message.MessageID
                callback := tgbotapi.NewCallback(update.CallbackQuery.ID, "")
                h.bot.Send(callback)
        }</span> else<span class="cov0" title="0"> if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Error: both CallbackQuery and Message are nil")
                return
        }</span>

        // Получаем врачей клиники через расписание
        <span class="cov8" title="1">criteria := &amp;models.SearchCriteria{
                ClinicID: clinicID,
        }
        vets, err := h.db.FindAvailableVets(criteria)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding vets by clinic: %v", err)
                msg := tgbotapi.NewMessage(chatID, "Ошибка при поиске врачей")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Found %d veterinarians for clinic ID: %d", len(vets), clinicID)

        // Получаем информацию о клинике
        clinics, err := h.db.GetAllClinics()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting clinics: %v", err)
                msg := tgbotapi.NewMessage(chatID, "Ошибка при получении информации о клинике")
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">var clinicName string
        for _, c := range clinics </span><span class="cov8" title="1">{
                if c.ID == clinicID </span><span class="cov8" title="1">{
                        clinicName = c.Name
                        break</span>
                }
        }

        // Если клиника не найдена, используем заглушку
        <span class="cov8" title="1">if clinicName == "" </span><span class="cov0" title="0">{
                clinicName = "Неизвестная клиника"
        }</span>

        // Клавиатура с кнопками навигации
        <span class="cov8" title="1">keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔙 К клиникам", "main_clinics"),
                        tgbotapi.NewInlineKeyboardButtonData("🏠 Главное меню", "main_menu"),
                ),
        )

        if len(vets) == 0 </span><span class="cov8" title="1">{
                msg := tgbotapi.NewMessage(chatID,
                        fmt.Sprintf("🏥 *Врачи в клинике \"%s\" не найдены*\n\nПопробуйте выбрать другую клинику.", clinicName))
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
                return
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString(fmt.Sprintf("🏥 *Врачи в клинике \"%s\":*\n\n", html.EscapeString(clinicName)))

        for i, vet := range vets </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("**%d. %s %s**\n", i+1, html.EscapeString(vet.FirstName), html.EscapeString(vet.LastName)))
                sb.WriteString(fmt.Sprintf("📞 *Телефон:* `%s`\n", html.EscapeString(vet.Phone)))

                if vet.Email.Valid &amp;&amp; vet.Email.String != "" </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("📧 *Email:* %s\n", html.EscapeString(vet.Email.String)))
                }</span>

                <span class="cov8" title="1">if vet.ExperienceYears.Valid </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("💼 *Опыт:* %d лет\n", vet.ExperienceYears.Int64))
                }</span>

                // Специализации врача
                <span class="cov8" title="1">specs, err := h.db.GetSpecializationsByVetID(vet.ID)
                if err == nil &amp;&amp; len(specs) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("🎯 *Специализации:* ")
                        specNames := make([]string, len(specs))
                        for j, spec := range specs </span><span class="cov0" title="0">{
                                specNames[j] = html.EscapeString(spec.Name)
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(strings.Join(specNames, ", "))
                        sb.WriteString("\n")</span>
                }

                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">if update.CallbackQuery != nil &amp;&amp; messageID != 0 </span><span class="cov8" title="1">{
                editMsg := tgbotapi.NewEditMessageText(chatID, messageID, sb.String())
                editMsg.ParseMode = "Markdown"
                editMsg.ReplyMarkup = &amp;keyboard
                h.bot.Send(editMsg)
        }</span> else<span class="cov0" title="0"> {
                msg := tgbotapi.NewMessage(chatID, sb.String())
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
        }</span>
}

// HandleCallback обрабатывает все inline callback запросы
func (h *VetHandlers) HandleCallback(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleCallback called")

        callback := update.CallbackQuery
        data := callback.Data

        log.Printf("Callback data: %s", data)

        // Обрабатываем разные типы callback данных
        switch </span>{
        case data == "main_menu":<span class="cov8" title="1">
                h.showMainMenu(callback)</span>
        case data == "main_specializations":<span class="cov0" title="0">
                h.HandleSpecializations(update)</span>
        case data == "main_time":<span class="cov0" title="0">
                h.HandleSearch(update)</span>
        case data == "main_clinics":<span class="cov0" title="0">
                h.HandleClinics(update)</span>
        case data == "main_help":<span class="cov0" title="0">
                h.HandleHelp(update)</span>
        case strings.HasPrefix(data, "search_spec_"):<span class="cov8" title="1">
                h.handleSearchSpecCallback(callback)</span>
        case strings.HasPrefix(data, "search_day_"):<span class="cov0" title="0">
                h.handleDaySelection(callback)</span>
        case strings.HasPrefix(data, "search_clinic_"):<span class="cov0" title="0">
                h.handleSearchClinicCallback(callback)</span>
        default:<span class="cov8" title="1">
                // Неизвестный callback
                callbackConfig := tgbotapi.NewCallback(callback.ID, "Неизвестная команда")
                h.bot.Request(callbackConfig)</span>
        }
}

// showMainMenu показывает главное меню
func (h *VetHandlers) showMainMenu(callback *tgbotapi.CallbackQuery) <span class="cov8" title="1">{
        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔍 Поиск по специализациям", "main_specializations"),
                        tgbotapi.NewInlineKeyboardButtonData("🕐 Поиск по времени", "main_time"),
                ),
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🏥 Поиск по клиникам", "main_clinics"),
                        tgbotapi.NewInlineKeyboardButtonData("ℹ️ Помощь", "main_help"),
                ),
        )

        editMsg := tgbotapi.NewEditMessageText(callback.Message.Chat.ID, callback.Message.MessageID,
                `🐾 Добро пожаловать в VetBot! 🐾

Я ваш помощник в поиске ветеринарных врачей. Выберите способ поиска:`)
        editMsg.ReplyMarkup = &amp;keyboard

        _, err := h.bot.Send(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error editing message to main menu: %v", err)
                // Если редактирование не удалось, отправляем новое сообщение
                msg := tgbotapi.NewMessage(callback.Message.Chat.ID,
                        `🐾 Добро пожаловать в VetBot! 🐾

Я ваш помощник в поиске ветеринарных врачей. Выберите способ поиска:`)
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
        }</span>

        <span class="cov8" title="1">callbackConfig := tgbotapi.NewCallback(callback.ID, "")
        h.bot.Request(callbackConfig)</span>
}

// handleSearchSpecCallback обрабатывает callback поиска по специализации
func (h *VetHandlers) handleSearchSpecCallback(callback *tgbotapi.CallbackQuery) <span class="cov8" title="1">{
        specIDStr := strings.TrimPrefix(callback.Data, "search_spec_")
        specID, err := strconv.Atoi(specIDStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error parsing specialization ID: %v", err)
                callbackConfig := tgbotapi.NewCallback(callback.ID, "Ошибка обработки запроса")
                h.bot.Request(callbackConfig)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Searching for specialization ID: %d", specID)

        // Создаем update для передачи в HandleSearchBySpecialization
        update := tgbotapi.Update{
                CallbackQuery: callback,
        }
        h.HandleSearchBySpecialization(update, specID)</span>
}

// handleSearchClinicCallback обрабатывает callback поиска по клинике
func (h *VetHandlers) handleSearchClinicCallback(callback *tgbotapi.CallbackQuery) <span class="cov0" title="0">{
        clinicIDStr := strings.TrimPrefix(callback.Data, "search_clinic_")
        clinicID, err := strconv.Atoi(clinicIDStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing clinic ID: %v", err)
                callbackConfig := tgbotapi.NewCallback(callback.ID, "Ошибка обработки запроса")
                h.bot.Request(callbackConfig)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Searching for clinic ID: %d", clinicID)

        update := tgbotapi.Update{
                CallbackQuery: callback,
        }
        h.HandleSearchByClinic(update, clinicID)</span>
}

// handleDaySelection обрабатывает выбор дня для поиска
func (h *VetHandlers) handleDaySelection(callback *tgbotapi.CallbackQuery) <span class="cov8" title="1">{
        log.Printf("handleDaySelection called")

        data := callback.Data
        dayStr := strings.TrimPrefix(data, "search_day_")
        day, err := strconv.Atoi(dayStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing day: %v", err)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Searching for day: %d", day)

        criteria := &amp;models.SearchCriteria{
                DayOfWeek: day,
        }

        vets, err := h.db.FindAvailableVets(criteria)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding vets: %v", err)
                callbackConfig := tgbotapi.NewCallback(callback.ID, "Ошибка при поиске врачей")
                h.bot.Request(callbackConfig)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("Found %d vets for day %d", len(vets), day)

        // Клавиатура с кнопками навигации
        keyboard := tgbotapi.NewInlineKeyboardMarkup(
                tgbotapi.NewInlineKeyboardRow(
                        tgbotapi.NewInlineKeyboardButtonData("🔙 К дням недели", "main_time"),
                        tgbotapi.NewInlineKeyboardButtonData("🏠 Главное меню", "main_menu"),
                ),
        )

        if len(vets) == 0 </span><span class="cov8" title="1">{
                dayName := getDayName(day)
                msg := tgbotapi.NewMessage(callback.Message.Chat.ID,
                        fmt.Sprintf("🕐 *Врачи, работающие в %s, не найдены*\n\nПопробуйте выбрать другой день.", dayName))
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
                callbackConfig := tgbotapi.NewCallback(callback.ID, "Поиск завершен")
                h.bot.Request(callbackConfig)
                return
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        dayName := getDayName(day)
        sb.WriteString(fmt.Sprintf("🕐 *Врачи, работающие в %s:*\n\n", dayName))

        for i, vet := range vets </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("**%d. %s %s**\n", i+1, html.EscapeString(vet.FirstName), html.EscapeString(vet.LastName)))
                sb.WriteString(fmt.Sprintf("📞 *Телефон:* `%s`\n", html.EscapeString(vet.Phone)))

                if vet.Email.Valid &amp;&amp; vet.Email.String != "" </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("📧 *Email:* %s\n", html.EscapeString(vet.Email.String)))
                }</span>

                <span class="cov8" title="1">if vet.ExperienceYears.Valid </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("💼 *Опыт:* %d лет\n", vet.ExperienceYears.Int64))
                }</span>

                // Расписание для выбранного дня
                <span class="cov8" title="1">schedules, err := h.db.GetSchedulesByVetID(vet.ID)
                if err == nil </span><span class="cov8" title="1">{
                        for _, schedule := range schedules </span><span class="cov8" title="1">{
                                if schedule.DayOfWeek == day || day == 0 </span><span class="cov8" title="1">{
                                        scheduleDayName := getDayName(schedule.DayOfWeek)
                                        startTime := schedule.StartTime
                                        endTime := schedule.EndTime
                                        if startTime != "" &amp;&amp; endTime != "" &amp;&amp; startTime != "00:00" &amp;&amp; endTime != "00:00" </span><span class="cov8" title="1">{
                                                sb.WriteString(fmt.Sprintf("🕐 *%s:* %s-%s", scheduleDayName, startTime, endTime))
                                                if schedule.Clinic != nil &amp;&amp; schedule.Clinic.Name != "" </span><span class="cov0" title="0">{
                                                        sb.WriteString(fmt.Sprintf(" (%s)", html.EscapeString(schedule.Clinic.Name)))
                                                }</span>
                                                <span class="cov8" title="1">sb.WriteString("\n")</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">editMsg := tgbotapi.NewEditMessageText(callback.Message.Chat.ID, callback.Message.MessageID, sb.String())
        editMsg.ParseMode = "Markdown"
        editMsg.ReplyMarkup = &amp;keyboard

        _, err = h.bot.Send(editMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending day search results: %v", err)
                // Если редактирование не удалось, отправляем новое сообщение
                msg := tgbotapi.NewMessage(callback.Message.Chat.ID, sb.String())
                msg.ParseMode = "Markdown"
                msg.ReplyMarkup = keyboard
                h.bot.Send(msg)
        }</span>

        <span class="cov8" title="1">callbackConfig := tgbotapi.NewCallback(callback.ID, "Поиск завершен")
        h.bot.Request(callbackConfig)</span>
}

// HandleTest для тестирования
func (h *VetHandlers) HandleTest(update tgbotapi.Update) <span class="cov8" title="1">{
        log.Printf("HandleTest called")

        msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Тестовое сообщение: бот работает!")
        _, err := h.bot.Send(msg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending test message: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Test message sent successfully")
        }</span>
}

// getDayName возвращает русское название дня недели
func getDayName(day int) string <span class="cov8" title="1">{
        days := map[int]string{
                1: "понедельник",
                2: "вторник",
                3: "среду",
                4: "четверг",
                5: "пятницу",
                6: "субботу",
                7: "воскресенье",
                0: "любой день",
        }
        return days[day]
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"
)

// Config содержит все конфигурационные параметры приложения
type Config struct {
        TelegramToken string
        DatabaseURL   string
        Debug         bool
        AdminIDs      []int64
}

// LoadConfig загружает конфигурацию из переменных окружения
func LoadConfig() (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{}

        // Токен Telegram бота (обязательный параметр)
        config.TelegramToken = getEnv("TELEGRAM_TOKEN", "")
        if config.TelegramToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("TELEGRAM_TOKEN is required")
        }</span>

        // Безопасное логирование токена
        <span class="cov8" title="1">tokenPreview := config.TelegramToken
        if len(tokenPreview) &gt; 10 </span><span class="cov8" title="1">{
                tokenPreview = tokenPreview[:10] + "..."
        }</span>
        <span class="cov8" title="1">log.Printf("Telegram token loaded: %s", tokenPreview)

        // URL базы данных (обязательный параметр)
        config.DatabaseURL = getEnv("DATABASE_URL", "")
        if config.DatabaseURL == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATABASE_URL is required")
        }</span>
        <span class="cov8" title="1">log.Printf("Database URL loaded: %s", config.DatabaseURL)

        // Режим отладки (опционально)
        debugStr := getEnv("DEBUG", "false")
        config.Debug, _ = strconv.ParseBool(debugStr)
        log.Printf("Debug mode: %t", config.Debug)

        // ID администраторов (опционально)
        adminIDsStr := getEnv("ADMIN_IDS", "")
        log.Printf("Raw ADMIN_IDS from env: '%s'", adminIDsStr)

        if adminIDsStr != "" </span><span class="cov8" title="1">{
                config.AdminIDs = parseAdminIDs(adminIDsStr)
                log.Printf("Loaded admin IDs: %v", config.AdminIDs)
        }</span> else<span class="cov8" title="1"> {
                log.Printf("No admin IDs configured")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// parseAdminIDs парсит строку с ID администраторов
func parseAdminIDs(adminIDsStr string) []int64 <span class="cov8" title="1">{
        var adminIDs []int64
        ids := strings.Split(adminIDsStr, ",")

        for _, idStr := range ids </span><span class="cov8" title="1">{
                idStr = strings.TrimSpace(idStr)
                if idStr == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">id, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error parsing admin ID %s: %v", idStr, err)
                        continue</span>
                }
                <span class="cov8" title="1">adminIDs = append(adminIDs, id)</span>
        }

        <span class="cov8" title="1">return adminIDs</span>
}

// getEnv получает значение переменной окружения или возвращает значение по умолчанию
func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return value</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
